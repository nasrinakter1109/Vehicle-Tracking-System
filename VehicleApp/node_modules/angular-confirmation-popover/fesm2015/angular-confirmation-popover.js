import { Injectable, Component, Directive, Input, Output, EventEmitter, HostListener, ViewContainerRef, ElementRef, Injector, ComponentFactoryResolver, Renderer2, NgModule, InjectionToken } from '@angular/core';
import { Positioning } from 'positioning';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ConfirmationPopoverOptions {
    constructor() {
        this.confirmText = 'Confirm';
        this.cancelText = 'Cancel';
        this.confirmButtonType = 'success';
        this.cancelButtonType = 'default';
        this.placement = 'top';
        this.hideConfirmButton = false;
        this.hideCancelButton = false;
        this.popoverClass = '';
        this.appendToBody = false;
        this.reverseButtonOrder = false;
        this.closeOnOutsideClick = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
class ConfirmationPopoverWindowOptions extends ConfirmationPopoverOptions {
}
ConfirmationPopoverWindowOptions.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
class ConfirmationPopoverWindowComponent {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.options = options;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.options.onAfterViewInit();
    }
}
ConfirmationPopoverWindowComponent.decorators = [
    { type: Component, args: [{
                selector: 'mwl-confirmation-popover-window',
                styles: [
                    `
    .popover {
      display: block;
    }
    .bs-popover-top .arrow, .bs-popover-bottom .arrow {
      left: 50%;
    }
    .bs-popover-left .arrow, .bs-popover-right .arrow {
      top: 50%;
    }
    .btn {
      transition: none;
    }
    .confirm-btns {
      display: flex;
      justify-content: space-around;
    }
    .confirm-btn-container {
      flex-basis: 50%;
    }
    .confirm-btn-container:not(:first-child) {
      margin-left: 4px;
    }
    .confirm-btn-container:not(:last-child) {
      margin-right: 4px;
    }
    .confirm-btns-reversed {
      flex-direction: row-reverse;
    }
    .confirm-btns-reversed .confirm-btn-container:not(:first-child) {
      margin-right: 4px;
      margin-left: 0;
    }
    .confirm-btns-reversed .confirm-btn-container:not(:last-child) {
      margin-right: 0;
      margin-left: 4px;
    }
  `
                ],
                template: `
    <ng-template #defaultTemplate let-options="options">
      <div [ngClass]="[
        'popover',
        options.placement,
        'popover-' + options.placement,
        'bs-popover-' + options.placement,
        options.popoverClass
      ]">
        <div class="popover-arrow arrow"></div>
        <h3 class="popover-title popover-header" [innerHTML]="options.popoverTitle"></h3>
        <div class="popover-content popover-body">
          <p [innerHTML]="options.popoverMessage"></p>
          <div class="confirm-btns" [class.confirm-btns-reversed]="options.reverseButtonOrder">
            <div
              class="confirm-btn-container"
              *ngIf="!options.hideCancelButton">
              <button
                type="button"
                [mwlFocus]="options.focusButton === 'cancel'"
                [class]="'btn btn-block btn-' + options.cancelButtonType"
                (click)="options.onCancel({clickEvent: $event})"
                [innerHtml]="options.cancelText">
              </button>
            </div>
            <div
              class="confirm-btn-container"
              *ngIf="!options.hideConfirmButton">
              <button
                type="button"
                [mwlFocus]="options.focusButton === 'confirm'"
                [class]="'btn btn-block btn-' + options.confirmButtonType"
                (click)="options.onConfirm({clickEvent: $event})"
                [innerHtml]="options.confirmText">
              </button>
            </div>
          </div>
        </div>
      </div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="options.customTemplate || defaultTemplate"
      [ngTemplateOutletContext]="{options: options}">
    </ng-template>
  `
            },] },
];
/** @nocollapse */
ConfirmationPopoverWindowComponent.ctorParameters = () => [
    { type: ConfirmationPopoverWindowOptions }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * All properties can be set on the directive as attributes like so (use `ConfirmationPopoverModule.forRoot()` to configure them globally):
 * ```html
 * <button
 *  class="btn btn-default"
 *  mwlConfirmationPopover
 *  [popoverTitle]="popoverTitle"
 *  [popoverMessage]="popoverMessage"
 *  placement="left"
 *  (confirm)="confirmClicked = true"
 *  (cancel)="cancelClicked = true"
 *  [(isOpen)]="isOpen">
 *   Show confirm popover!
 * </button>
 * ```
 */
class ConfirmationPopoverDirective {
    /**
     * \@internal
     * @param {?} viewContainerRef
     * @param {?} elm
     * @param {?} defaultOptions
     * @param {?} cfr
     * @param {?} position
     * @param {?} renderer
     */
    constructor(viewContainerRef, elm, defaultOptions, cfr, position, renderer) {
        this.viewContainerRef = viewContainerRef;
        this.elm = elm;
        this.defaultOptions = defaultOptions;
        this.cfr = cfr;
        this.position = position;
        this.renderer = renderer;
        /**
         * Whether to disable showing the popover. Default `false`.
         */
        this.isDisabled = false;
        /**
         * Will open or show the popover when changed.
         * Can be sugared with `isOpenChange` to emulate 2-way binding like so `[(isOpen)]="isOpen"`
         */
        this.isOpen = false;
        /**
         * Will emit when the popover is opened or closed
         */
        this.isOpenChange = new EventEmitter(true);
        /**
         * An expression that is called when the confirm button is clicked.
         */
        this.confirm = new EventEmitter();
        /**
         * An expression that is called when the cancel button is clicked.
         */
        this.cancel = new EventEmitter();
        this.eventListeners = [];
    }
    /**
     * \@internal
     * @return {?}
     */
    ngOnInit() {
        this.isOpenChange.emit(false);
    }
    /**
     * \@internal
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["isOpen"]) {
            if (changes["isOpen"].currentValue === true) {
                this.showPopover();
            }
            else {
                this.hidePopover();
            }
        }
    }
    /**
     * \@internal
     * @return {?}
     */
    ngOnDestroy() {
        this.hidePopover();
    }
    /**
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onConfirm(event) {
        this.confirm.emit(event);
        this.hidePopover();
    }
    /**
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onCancel(event) {
        this.cancel.emit(event);
        this.hidePopover();
    }
    /**
     * \@internal
     * @return {?}
     */
    togglePopover() {
        if (!this.popover) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDocumentClick(event) {
        const /** @type {?} */ closeOnOutsideClick = typeof this.closeOnOutsideClick !== 'undefined' ?
            this.closeOnOutsideClick : this.defaultOptions.closeOnOutsideClick;
        if (this.popover &&
            !this.elm.nativeElement.contains(event.target) &&
            !this.popover.location.nativeElement.contains(event.target) &&
            closeOnOutsideClick) {
            this.hidePopover();
        }
    }
    /**
     * @return {?}
     */
    showPopover() {
        if (!this.popover && !this.isDisabled) {
            // work around for https://github.com/mattlewis92/angular-confirmation-popover/issues/65
            // otherwise the document click event gets fired after the click event
            // that triggered the popover to open (no idea why this is so)
            setTimeout(() => {
                this.eventListeners = [
                    this.renderer.listen('document', 'click', (event) => this.onDocumentClick(event)),
                    this.renderer.listen('document', 'touchend', (event) => this.onDocumentClick(event)),
                    this.renderer.listen('window', 'resize', () => this.positionPopover())
                ];
            });
            const /** @type {?} */ options = new ConfirmationPopoverWindowOptions();
            Object.assign(options, this.defaultOptions, {
                onConfirm: (event) => {
                    this.onConfirm(event);
                },
                onCancel: (event) => {
                    this.onCancel(event);
                },
                onAfterViewInit: () => {
                    this.positionPopover();
                }
            });
            const /** @type {?} */ optionalParams = [
                'confirmText',
                'cancelText',
                'placement',
                'confirmButtonType',
                'cancelButtonType',
                'focusButton',
                'hideConfirmButton',
                'hideCancelButton',
                'popoverClass',
                'appendToBody',
                'customTemplate',
                'reverseButtonOrder',
                'popoverTitle',
                'popoverMessage'
            ];
            optionalParams.forEach(param => {
                if (typeof this[param] !== 'undefined') {
                    (/** @type {?} */ (options))[param] = this[param];
                }
            });
            const /** @type {?} */ componentFactory = this.cfr.resolveComponentFactory(ConfirmationPopoverWindowComponent);
            const /** @type {?} */ childInjector = Injector.create([
                {
                    provide: ConfirmationPopoverWindowOptions,
                    useValue: options
                }
            ], this.viewContainerRef.parentInjector);
            this.popover = this.viewContainerRef.createComponent(componentFactory, this.viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                document.body.appendChild(this.popover.location.nativeElement);
            }
            this.isOpenChange.emit(true);
        }
    }
    /**
     * @return {?}
     */
    positionPopover() {
        if (this.popover) {
            const /** @type {?} */ popoverElement = this.popover.location.nativeElement.children[0];
            const /** @type {?} */ popoverPosition = this.position.positionElements(this.elm.nativeElement, popoverElement, this.placement || this.defaultOptions.placement, this.appendToBody || this.defaultOptions.appendToBody);
            this.renderer.setStyle(popoverElement, 'top', `${popoverPosition.top}px`);
            this.renderer.setStyle(popoverElement, 'left', `${popoverPosition.left}px`);
        }
    }
    /**
     * @return {?}
     */
    hidePopover() {
        if (this.popover) {
            this.popover.destroy();
            delete this.popover;
            this.isOpenChange.emit(false);
            this.eventListeners.forEach(fn => fn());
            this.eventListeners = [];
        }
    }
}
ConfirmationPopoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mwlConfirmationPopover]'
            },] },
];
/** @nocollapse */
ConfirmationPopoverDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: ConfirmationPopoverOptions },
    { type: ComponentFactoryResolver },
    { type: Positioning },
    { type: Renderer2 }
];
ConfirmationPopoverDirective.propDecorators = {
    popoverTitle: [{ type: Input }],
    popoverMessage: [{ type: Input }],
    confirmText: [{ type: Input }],
    cancelText: [{ type: Input }],
    placement: [{ type: Input }],
    confirmButtonType: [{ type: Input }],
    cancelButtonType: [{ type: Input }],
    focusButton: [{ type: Input }],
    hideConfirmButton: [{ type: Input }],
    hideCancelButton: [{ type: Input }],
    isDisabled: [{ type: Input }],
    isOpen: [{ type: Input }],
    customTemplate: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    confirm: [{ type: Output }],
    cancel: [{ type: Output }],
    popoverClass: [{ type: Input }],
    appendToBody: [{ type: Input }],
    reverseButtonOrder: [{ type: Input }],
    closeOnOutsideClick: [{ type: Input }],
    togglePopover: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A helper directive to focus buttons. You will only need this if using a custom template
 */
class FocusDirective {
    /**
     * @param {?} elm
     */
    constructor(elm) {
        this.elm = elm;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["mwlFocus"] && this.mwlFocus === true) {
            this.elm.nativeElement.focus();
        }
    }
}
FocusDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mwlFocus]'
            },] },
];
/** @nocollapse */
FocusDirective.ctorParameters = () => [
    { type: ElementRef }
];
FocusDirective.propDecorators = {
    mwlFocus: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ USER_OPTIONS = new InjectionToken('confirmation popover user options');
/**
 * @param {?} userOptions
 * @return {?}
 */
function optionsFactory(userOptions) {
    const /** @type {?} */ options = new ConfirmationPopoverOptions();
    Object.assign(options, userOptions);
    return options;
}
class ConfirmationPopoverModule {
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options = {}) {
        return {
            ngModule: ConfirmationPopoverModule,
            providers: [
                {
                    provide: USER_OPTIONS,
                    useValue: options
                },
                {
                    provide: ConfirmationPopoverOptions,
                    useFactory: optionsFactory,
                    deps: [USER_OPTIONS]
                },
                Positioning
            ]
        };
    }
}
ConfirmationPopoverModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ConfirmationPopoverDirective,
                    ConfirmationPopoverWindowComponent,
                    FocusDirective
                ],
                imports: [CommonModule],
                exports: [ConfirmationPopoverDirective, FocusDirective],
                entryComponents: [ConfirmationPopoverWindowComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { ConfirmationPopoverModule, ConfirmationPopoverOptions as ɵd, ConfirmationPopoverWindowOptions as ɵf, ConfirmationPopoverWindowComponent as ɵe, ConfirmationPopoverDirective as ɵc, USER_OPTIONS as ɵa, optionsFactory as ɵb, FocusDirective as ɵg };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1jb25maXJtYXRpb24tcG9wb3Zlci5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vYW5ndWxhci1jb25maXJtYXRpb24tcG9wb3Zlci9jb25maXJtYXRpb24tcG9wb3Zlci1vcHRpb25zLnByb3ZpZGVyLnRzIiwibmc6Ly9hbmd1bGFyLWNvbmZpcm1hdGlvbi1wb3BvdmVyL2NvbmZpcm1hdGlvbi1wb3BvdmVyLXdpbmRvdy1vcHRpb25zLnByb3ZpZGVyLnRzIiwibmc6Ly9hbmd1bGFyLWNvbmZpcm1hdGlvbi1wb3BvdmVyL2NvbmZpcm1hdGlvbi1wb3BvdmVyLXdpbmRvdy5jb21wb25lbnQudHMiLCJuZzovL2FuZ3VsYXItY29uZmlybWF0aW9uLXBvcG92ZXIvY29uZmlybWF0aW9uLXBvcG92ZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9hbmd1bGFyLWNvbmZpcm1hdGlvbi1wb3BvdmVyL2ZvY3VzLmRpcmVjdGl2ZS50cyIsIm5nOi8vYW5ndWxhci1jb25maXJtYXRpb24tcG9wb3Zlci9jb25maXJtYXRpb24tcG9wb3Zlci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBDb25maXJtYXRpb25Qb3BvdmVyT3B0aW9uc0ludGVyZmFjZSB7XG4gIC8qKlxuICAgKiBUaGUgcG9wb3ZlciB0aXRsZVxuICAgKi9cbiAgcG9wb3ZlclRpdGxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9wb3ZlciBtZXNzYWdlXG4gICAqL1xuICBwb3BvdmVyTWVzc2FnZT86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBvcG92ZXIgY29uZmlybWF0aW9uIGJ1dHRvbiB0ZXh0XG4gICAqL1xuICBjb25maXJtVGV4dD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBvcG92ZXIgY2FuY2VsIGJ1dHRvbiB0ZXh0XG4gICAqL1xuICBjYW5jZWxUZXh0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9wb3ZlciBjb25maXJtIGJ1dHRvbiB0eXBlIGUuZy4gYHN1Y2Nlc3NgLCBgZGFuZ2VyYCBldGNcbiAgICovXG4gIGNvbmZpcm1CdXR0b25UeXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcG9wb3ZlciBjYW5jZWwgYnV0dG9uIHR5cGUgIGUuZy4gYHN1Y2Nlc3NgLCBgZGFuZ2VyYCBldGNcbiAgICovXG4gIGNhbmNlbEJ1dHRvblR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwb3BvdmVyIHBsYWNlbWVudC4gQ2FuIGJlIGB0b3BgLCBgYm90dG9tYCwgYGxlZnRgLCBgcmlnaHRgXG4gICAqL1xuICBwbGFjZW1lbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoaWNoIGJ1dHRvbiB0byBjYW5jZWwuIENhbiBiZSBlaXRoZXIgYGNvbmZpcm1gIG9yIGBjYW5jZWxgXG4gICAqL1xuICBmb2N1c0J1dHRvbj86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0byBoaWRlIHRoZSBjb25maXJtYXRpb24gYnV0dG9uXG4gICAqL1xuICBoaWRlQ29uZmlybUJ1dHRvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaGlkZSB0aGUgY2FuY2VsIGJ1dHRvblxuICAgKi9cbiAgaGlkZUNhbmNlbEJ1dHRvbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgY3VzdG9tIENTUyBjbGFzcyB0byBiZSBhZGRlZCB0byB0aGUgcG9wb3ZlclxuICAgKi9cbiAgcG9wb3ZlckNsYXNzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGFwcGVuZCB0aGUgcG9wb3ZlciB0byB0aGUgZG9jdW1lbnQgYm9keVxuICAgKi9cbiAgYXBwZW5kVG9Cb2R5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3dhcCB0aGUgb3JkZXIgb2YgdGhlIGNvbmZpcm0gYW5kIGNhbmNlbCBidXR0b25zXG4gICAqL1xuICByZXZlcnNlQnV0dG9uT3JkZXI/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcG9wb3ZlciBzaG91bGQgc3RheSBvcGVuIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBpdFxuICAgKi9cbiAgY2xvc2VPbk91dHNpZGVDbGljaz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Qb3BvdmVyT3B0aW9uc1xuICBpbXBsZW1lbnRzIENvbmZpcm1hdGlvblBvcG92ZXJPcHRpb25zSW50ZXJmYWNlIHtcbiAgcG9wb3ZlclRpdGxlOiBzdHJpbmc7XG4gIHBvcG92ZXJNZXNzYWdlOiBzdHJpbmc7XG4gIGNvbmZpcm1UZXh0OiBzdHJpbmcgPSAnQ29uZmlybSc7XG4gIGNhbmNlbFRleHQ6IHN0cmluZyA9ICdDYW5jZWwnO1xuICBjb25maXJtQnV0dG9uVHlwZTogc3RyaW5nID0gJ3N1Y2Nlc3MnO1xuICBjYW5jZWxCdXR0b25UeXBlOiBzdHJpbmcgPSAnZGVmYXVsdCc7XG4gIHBsYWNlbWVudDogc3RyaW5nID0gJ3RvcCc7XG4gIGZvY3VzQnV0dG9uOiBzdHJpbmc7XG4gIGhpZGVDb25maXJtQnV0dG9uOiBib29sZWFuID0gZmFsc2U7XG4gIGhpZGVDYW5jZWxCdXR0b246IGJvb2xlYW4gPSBmYWxzZTtcbiAgcG9wb3ZlckNsYXNzOiBzdHJpbmcgPSAnJztcbiAgYXBwZW5kVG9Cb2R5OiBib29sZWFuID0gZmFsc2U7XG4gIHJldmVyc2VCdXR0b25PcmRlcjogYm9vbGVhbiA9IGZhbHNlO1xuICBjbG9zZU9uT3V0c2lkZUNsaWNrOiBib29sZWFuID0gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IENvbmZpcm1DYW5jZWxFdmVudCB9IGZyb20gJy4vY29uZmlybWF0aW9uLXBvcG92ZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IEluamVjdGFibGUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25maXJtYXRpb25Qb3BvdmVyT3B0aW9ucyB9IGZyb20gJy4vY29uZmlybWF0aW9uLXBvcG92ZXItb3B0aW9ucy5wcm92aWRlcic7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Qb3BvdmVyV2luZG93T3B0aW9ucyBleHRlbmRzIENvbmZpcm1hdGlvblBvcG92ZXJPcHRpb25zIHtcbiAgcHVibGljIG9uQ29uZmlybTogKGV2ZW50OiBDb25maXJtQ2FuY2VsRXZlbnQpID0+IHZvaWQ7XG4gIHB1YmxpYyBvbkNhbmNlbDogKGV2ZW50OiBDb25maXJtQ2FuY2VsRXZlbnQpID0+IHZvaWQ7XG4gIHB1YmxpYyBvbkFmdGVyVmlld0luaXQ6ICgpID0+IHZvaWQ7XG4gIHB1YmxpYyBjdXN0b21UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pjtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29uZmlybWF0aW9uUG9wb3ZlcldpbmRvd09wdGlvbnMgfSBmcm9tICcuL2NvbmZpcm1hdGlvbi1wb3BvdmVyLXdpbmRvdy1vcHRpb25zLnByb3ZpZGVyJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbXdsLWNvbmZpcm1hdGlvbi1wb3BvdmVyLXdpbmRvdycsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAucG9wb3ZlciB7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG4gICAgLmJzLXBvcG92ZXItdG9wIC5hcnJvdywgLmJzLXBvcG92ZXItYm90dG9tIC5hcnJvdyB7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgfVxuICAgIC5icy1wb3BvdmVyLWxlZnQgLmFycm93LCAuYnMtcG9wb3Zlci1yaWdodCAuYXJyb3cge1xuICAgICAgdG9wOiA1MCU7XG4gICAgfVxuICAgIC5idG4ge1xuICAgICAgdHJhbnNpdGlvbjogbm9uZTtcbiAgICB9XG4gICAgLmNvbmZpcm0tYnRucyB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgfVxuICAgIC5jb25maXJtLWJ0bi1jb250YWluZXIge1xuICAgICAgZmxleC1iYXNpczogNTAlO1xuICAgIH1cbiAgICAuY29uZmlybS1idG4tY29udGFpbmVyOm5vdCg6Zmlyc3QtY2hpbGQpIHtcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XG4gICAgfVxuICAgIC5jb25maXJtLWJ0bi1jb250YWluZXI6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICB9XG4gICAgLmNvbmZpcm0tYnRucy1yZXZlcnNlZCB7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgfVxuICAgIC5jb25maXJtLWJ0bnMtcmV2ZXJzZWQgLmNvbmZpcm0tYnRuLWNvbnRhaW5lcjpub3QoOmZpcnN0LWNoaWxkKSB7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDRweDtcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xuICAgIH1cbiAgICAuY29uZmlybS1idG5zLXJldmVyc2VkIC5jb25maXJtLWJ0bi1jb250YWluZXI6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gICAgICBtYXJnaW4tbGVmdDogNHB4O1xuICAgIH1cbiAgYFxuICBdLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdFRlbXBsYXRlIGxldC1vcHRpb25zPVwib3B0aW9uc1wiPlxuICAgICAgPGRpdiBbbmdDbGFzc109XCJbXG4gICAgICAgICdwb3BvdmVyJyxcbiAgICAgICAgb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgICdwb3BvdmVyLScgKyBvcHRpb25zLnBsYWNlbWVudCxcbiAgICAgICAgJ2JzLXBvcG92ZXItJyArIG9wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICBvcHRpb25zLnBvcG92ZXJDbGFzc1xuICAgICAgXVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvdyBhcnJvd1wiPjwvZGl2PlxuICAgICAgICA8aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlIHBvcG92ZXItaGVhZGVyXCIgW2lubmVySFRNTF09XCJvcHRpb25zLnBvcG92ZXJUaXRsZVwiPjwvaDM+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyLWNvbnRlbnQgcG9wb3Zlci1ib2R5XCI+XG4gICAgICAgICAgPHAgW2lubmVySFRNTF09XCJvcHRpb25zLnBvcG92ZXJNZXNzYWdlXCI+PC9wPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb25maXJtLWJ0bnNcIiBbY2xhc3MuY29uZmlybS1idG5zLXJldmVyc2VkXT1cIm9wdGlvbnMucmV2ZXJzZUJ1dHRvbk9yZGVyXCI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzPVwiY29uZmlybS1idG4tY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgKm5nSWY9XCIhb3B0aW9ucy5oaWRlQ2FuY2VsQnV0dG9uXCI+XG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBbbXdsRm9jdXNdPVwib3B0aW9ucy5mb2N1c0J1dHRvbiA9PT0gJ2NhbmNlbCdcIlxuICAgICAgICAgICAgICAgIFtjbGFzc109XCInYnRuIGJ0bi1ibG9jayBidG4tJyArIG9wdGlvbnMuY2FuY2VsQnV0dG9uVHlwZVwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9wdGlvbnMub25DYW5jZWwoe2NsaWNrRXZlbnQ6ICRldmVudH0pXCJcbiAgICAgICAgICAgICAgICBbaW5uZXJIdG1sXT1cIm9wdGlvbnMuY2FuY2VsVGV4dFwiPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzcz1cImNvbmZpcm0tYnRuLWNvbnRhaW5lclwiXG4gICAgICAgICAgICAgICpuZ0lmPVwiIW9wdGlvbnMuaGlkZUNvbmZpcm1CdXR0b25cIj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIFttd2xGb2N1c109XCJvcHRpb25zLmZvY3VzQnV0dG9uID09PSAnY29uZmlybSdcIlxuICAgICAgICAgICAgICAgIFtjbGFzc109XCInYnRuIGJ0bi1ibG9jayBidG4tJyArIG9wdGlvbnMuY29uZmlybUJ1dHRvblR5cGVcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJvcHRpb25zLm9uQ29uZmlybSh7Y2xpY2tFdmVudDogJGV2ZW50fSlcIlxuICAgICAgICAgICAgICAgIFtpbm5lckh0bWxdPVwib3B0aW9ucy5jb25maXJtVGV4dFwiPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLXRlbXBsYXRlXG4gICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJvcHRpb25zLmN1c3RvbVRlbXBsYXRlIHx8IGRlZmF1bHRUZW1wbGF0ZVwiXG4gICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie29wdGlvbnM6IG9wdGlvbnN9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Qb3BvdmVyV2luZG93Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25zOiBDb25maXJtYXRpb25Qb3BvdmVyV2luZG93T3B0aW9ucykge31cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25zLm9uQWZ0ZXJWaWV3SW5pdCgpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBDb21wb25lbnRSZWYsXG4gIE9uRGVzdHJveSxcbiAgRWxlbWVudFJlZixcbiAgT25DaGFuZ2VzLFxuICBPbkluaXQsXG4gIEluamVjdG9yLFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIFJlbmRlcmVyMixcbiAgVGVtcGxhdGVSZWYsXG4gIENvbXBvbmVudEZhY3RvcnksXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25maXJtYXRpb25Qb3BvdmVyV2luZG93Q29tcG9uZW50IH0gZnJvbSAnLi9jb25maXJtYXRpb24tcG9wb3Zlci13aW5kb3cuY29tcG9uZW50JztcbmltcG9ydCB7IENvbmZpcm1hdGlvblBvcG92ZXJPcHRpb25zIH0gZnJvbSAnLi9jb25maXJtYXRpb24tcG9wb3Zlci1vcHRpb25zLnByb3ZpZGVyJztcbmltcG9ydCB7IENvbmZpcm1hdGlvblBvcG92ZXJXaW5kb3dPcHRpb25zIH0gZnJvbSAnLi9jb25maXJtYXRpb24tcG9wb3Zlci13aW5kb3ctb3B0aW9ucy5wcm92aWRlcic7XG5pbXBvcnQgeyBQb3NpdGlvbmluZyB9IGZyb20gJ3Bvc2l0aW9uaW5nJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25maXJtQ2FuY2VsRXZlbnQge1xuICBjbGlja0V2ZW50OiBNb3VzZUV2ZW50O1xufVxuXG4vKipcbiAqIEFsbCBwcm9wZXJ0aWVzIGNhbiBiZSBzZXQgb24gdGhlIGRpcmVjdGl2ZSBhcyBhdHRyaWJ1dGVzIGxpa2Ugc28gKHVzZSBgQ29uZmlybWF0aW9uUG9wb3Zlck1vZHVsZS5mb3JSb290KClgIHRvIGNvbmZpZ3VyZSB0aGVtIGdsb2JhbGx5KTpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b25cbiAqICBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiXG4gKiAgbXdsQ29uZmlybWF0aW9uUG9wb3ZlclxuICogIFtwb3BvdmVyVGl0bGVdPVwicG9wb3ZlclRpdGxlXCJcbiAqICBbcG9wb3Zlck1lc3NhZ2VdPVwicG9wb3Zlck1lc3NhZ2VcIlxuICogIHBsYWNlbWVudD1cImxlZnRcIlxuICogIChjb25maXJtKT1cImNvbmZpcm1DbGlja2VkID0gdHJ1ZVwiXG4gKiAgKGNhbmNlbCk9XCJjYW5jZWxDbGlja2VkID0gdHJ1ZVwiXG4gKiAgWyhpc09wZW4pXT1cImlzT3BlblwiPlxuICogICBTaG93IGNvbmZpcm0gcG9wb3ZlciFcbiAqIDwvYnV0dG9uPlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttd2xDb25maXJtYXRpb25Qb3BvdmVyXSdcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uUG9wb3ZlckRpcmVjdGl2ZVxuICBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBPbkluaXQge1xuICAvKipcbiAgICogVGhlIHRpdGxlIG9mIHRoZSBwb3BvdmVyXG4gICAqL1xuICBASW5wdXQoKSBwb3BvdmVyVGl0bGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGJvZHkgdGV4dCBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG4gIEBJbnB1dCgpIHBvcG92ZXJNZXNzYWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IG9mIHRoZSBjb25maXJtIGJ1dHRvbi4gRGVmYXVsdCBgQ29uZmlybWBcbiAgICovXG4gIEBJbnB1dCgpIGNvbmZpcm1UZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IG9mIHRoZSBjYW5jZWwgYnV0dG9uLiBEZWZhdWx0IGBDYW5jZWxgXG4gICAqL1xuICBASW5wdXQoKSBjYW5jZWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcG92ZXIuIEl0IGNhbiBiZSBlaXRoZXIgYHRvcGAsIGByaWdodGAsIGBib3R0b21gIG9yIGBsZWZ0YC4gRGVmYXVsdCBgdG9wYFxuICAgKi9cbiAgQElucHV0KCkgcGxhY2VtZW50OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBib290c3RyYXAgYnV0dG9uIHR5cGUgb2YgdGhlIGNvbmZpcm0gYnV0dG9uLiBJdCBjYW4gYmUgYW55IHN1cHBvcnRlZCBib290c3RyYXAgY29sb3IgdHlwZVxuICAgKiBlLmcuIGBkZWZhdWx0YCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCBldGMuIERlZmF1bHQgYHN1Y2Nlc3NgXG4gICAqL1xuICBASW5wdXQoKSBjb25maXJtQnV0dG9uVHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYm9vdHN0cmFwIGJ1dHRvbiB0eXBlIG9mIHRoZSBjYW5jZWwgYnV0dG9uLiBJdCBjYW4gYmUgYW55IHN1cHBvcnRlZCBib290c3RyYXAgY29sb3IgdHlwZVxuICAgKiBlLmcuIGBkZWZhdWx0YCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCBldGMuIERlZmF1bHQgYGRlZmF1bHRgXG4gICAqL1xuICBASW5wdXQoKSBjYW5jZWxCdXR0b25UeXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNldCB0byBlaXRoZXIgYGNvbmZpcm1gIG9yIGBjYW5jZWxgIHRvIGZvY3VzIHRoZSBjb25maXJtIG9yIGNhbmNlbCBidXR0b24uXG4gICAqIElmIG9taXR0ZWQsIGJ5IGRlZmF1bHQgaXQgd2lsbCBub3QgZm9jdXMgZWl0aGVyIGJ1dHRvbi5cbiAgICovXG4gIEBJbnB1dCgpIGZvY3VzQnV0dG9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaGlkZSB0aGUgY29uZmlybSBidXR0b24uIERlZmF1bHQgYGZhbHNlYC5cbiAgICovXG4gIEBJbnB1dCgpIGhpZGVDb25maXJtQnV0dG9uOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGhpZGUgdGhlIGNhbmNlbCBidXR0b24uIERlZmF1bHQgYGZhbHNlYC5cbiAgICovXG4gIEBJbnB1dCgpIGhpZGVDYW5jZWxCdXR0b246IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzYWJsZSBzaG93aW5nIHRoZSBwb3BvdmVyLiBEZWZhdWx0IGBmYWxzZWAuXG4gICAqL1xuICBASW5wdXQoKSBpc0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdpbGwgb3BlbiBvciBzaG93IHRoZSBwb3BvdmVyIHdoZW4gY2hhbmdlZC5cbiAgICogQ2FuIGJlIHN1Z2FyZWQgd2l0aCBgaXNPcGVuQ2hhbmdlYCB0byBlbXVsYXRlIDItd2F5IGJpbmRpbmcgbGlrZSBzbyBgWyhpc09wZW4pXT1cImlzT3BlblwiYFxuICAgKi9cbiAgQElucHV0KCkgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIGEgPG5nLXRlbXBsYXRlPiB0YWcgdGhhdCBpZiBzZXQgd2lsbCBvdmVycmlkZSB0aGUgcG9wb3ZlcnMgdGVtcGxhdGUuIFVzZSBsaWtlIHNvOlxuICAgKiBgYGBodG1sXG4gICAqIDxuZy10ZW1wbGF0ZSAjY3VzdG9tVGVtcGxhdGUgbGV0LW9wdGlvbnM9XCJvcHRpb25zXCI+XG4gICAqICAgPGRpdiBbY2xhc3NdPVwiJ3BvcG92ZXIgJyArIG9wdGlvbnMucGxhY2VtZW50XCIgc3R5bGU9XCJkaXNwbGF5OiBibG9ja1wiPlxuICAgKiAgICAgTXkgY3VzdG9tIHRlbXBsYXRlXG4gICAqICAgPC9kaXY+XG4gICAqIDwvbmctdGVtcGxhdGU+XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGVuIHBhc3MgY3VzdG9tVGVtcGxhdGUgdG8gdGhlIG13bENvbmZpcm1hdGlvblBvcG92ZXIgZGlyZWN0aXZlIGxpa2Ugc28gYFtjdXN0b21UZW1wbGF0ZV09XCJjdXN0b21UZW1wbGF0ZVwiYFxuICAgKi9cbiAgQElucHV0KCkgY3VzdG9tVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgLyoqXG4gICAqIFdpbGwgZW1pdCB3aGVuIHRoZSBwb3BvdmVyIGlzIG9wZW5lZCBvciBjbG9zZWRcbiAgICovXG4gIEBPdXRwdXQoKSBpc09wZW5DaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG5cbiAgLyoqXG4gICAqIEFuIGV4cHJlc3Npb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY29uZmlybSBidXR0b24gaXMgY2xpY2tlZC5cbiAgICovXG4gIEBPdXRwdXQoKSBjb25maXJtOiBFdmVudEVtaXR0ZXI8Q29uZmlybUNhbmNlbEV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogQW4gZXhwcmVzc2lvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAqL1xuICBAT3V0cHV0KCkgY2FuY2VsOiBFdmVudEVtaXR0ZXI8Q29uZmlybUNhbmNlbEV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogQSBjdXN0b20gQ1NTIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb3BvdmVyXG4gICAqL1xuICBASW5wdXQoKSBwb3BvdmVyQ2xhc3M6IHN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCBib2R5IHJhdGhlciB0aGFuIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgICovXG4gIEBJbnB1dCgpIGFwcGVuZFRvQm9keTogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3dhcCB0aGUgb3JkZXIgb2YgdGhlIGNvbmZpcm0gYW5kIGNhbmNlbCBidXR0b25zXG4gICAqL1xuICBASW5wdXQoKSByZXZlcnNlQnV0dG9uT3JkZXI6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHBvcG92ZXIgc2hvdWxkIHN0YXkgb3BlbiBldmVuIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBpdFxuICAgKi9cbiAgQElucHV0KCkgY2xvc2VPbk91dHNpZGVDbGljazogYm9vbGVhbjtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwb3BvdmVyOiBDb21wb25lbnRSZWY8Q29uZmlybWF0aW9uUG9wb3ZlcldpbmRvd0NvbXBvbmVudD47XG5cbiAgcHJpdmF0ZSBldmVudExpc3RlbmVyczogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBlbG06IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBkZWZhdWx0T3B0aW9uczogQ29uZmlybWF0aW9uUG9wb3Zlck9wdGlvbnMsXG4gICAgcHJpdmF0ZSBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBwcml2YXRlIHBvc2l0aW9uOiBQb3NpdGlvbmluZyxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaXNPcGVuQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLmlzT3Blbikge1xuICAgICAgaWYgKGNoYW5nZXMuaXNPcGVuLmN1cnJlbnRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNob3dQb3BvdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGVQb3BvdmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5oaWRlUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25Db25maXJtKGV2ZW50OiBDb25maXJtQ2FuY2VsRXZlbnQpIHtcbiAgICB0aGlzLmNvbmZpcm0uZW1pdChldmVudCk7XG4gICAgdGhpcy5oaWRlUG9wb3ZlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb25DYW5jZWwoZXZlbnQ6IENvbmZpcm1DYW5jZWxFdmVudCkge1xuICAgIHRoaXMuY2FuY2VsLmVtaXQoZXZlbnQpO1xuICAgIHRoaXMuaGlkZVBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgdG9nZ2xlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucG9wb3Zlcikge1xuICAgICAgdGhpcy5zaG93UG9wb3ZlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGVQb3BvdmVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkRvY3VtZW50Q2xpY2soZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgY2xvc2VPbk91dHNpZGVDbGljayA9IHR5cGVvZiB0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2sgIT09ICd1bmRlZmluZWQnID8gXG4gICAgICB0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2sgOiB0aGlzLmRlZmF1bHRPcHRpb25zLmNsb3NlT25PdXRzaWRlQ2xpY2s7XG4gICAgaWYgKFxuICAgICAgdGhpcy5wb3BvdmVyICYmXG4gICAgICAhdGhpcy5lbG0ubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpICYmXG4gICAgICAhdGhpcy5wb3BvdmVyLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJlxuICAgICAgY2xvc2VPbk91dHNpZGVDbGlja1xuICAgICkge1xuICAgICAgdGhpcy5oaWRlUG9wb3ZlcigpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2hvd1BvcG92ZXIoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBvcG92ZXIgJiYgIXRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgLy8gd29yayBhcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0bGV3aXM5Mi9hbmd1bGFyLWNvbmZpcm1hdGlvbi1wb3BvdmVyL2lzc3Vlcy82NVxuICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBkb2N1bWVudCBjbGljayBldmVudCBnZXRzIGZpcmVkIGFmdGVyIHRoZSBjbGljayBldmVudFxuICAgICAgLy8gdGhhdCB0cmlnZ2VyZWQgdGhlIHBvcG92ZXIgdG8gb3BlbiAobm8gaWRlYSB3aHkgdGhpcyBpcyBzbylcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIChldmVudDogRXZlbnQpID0+XG4gICAgICAgICAgICB0aGlzLm9uRG9jdW1lbnRDbGljayhldmVudClcbiAgICAgICAgICApLFxuICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICd0b3VjaGVuZCcsIChldmVudDogRXZlbnQpID0+XG4gICAgICAgICAgICB0aGlzLm9uRG9jdW1lbnRDbGljayhldmVudClcbiAgICAgICAgICApLFxuICAgICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCd3aW5kb3cnLCAncmVzaXplJywgKCkgPT4gdGhpcy5wb3NpdGlvblBvcG92ZXIoKSlcbiAgICAgICAgXTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0gbmV3IENvbmZpcm1hdGlvblBvcG92ZXJXaW5kb3dPcHRpb25zKCk7XG4gICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMsIHtcbiAgICAgICAgb25Db25maXJtOiAoZXZlbnQ6IENvbmZpcm1DYW5jZWxFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgIHRoaXMub25Db25maXJtKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DYW5jZWw6IChldmVudDogQ29uZmlybUNhbmNlbEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgICAgdGhpcy5vbkNhbmNlbChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWZ0ZXJWaWV3SW5pdDogKCk6IHZvaWQgPT4ge1xuICAgICAgICAgIHRoaXMucG9zaXRpb25Qb3BvdmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvcHRpb25hbFBhcmFtczogQXJyYXk8a2V5b2YgQ29uZmlybWF0aW9uUG9wb3ZlckRpcmVjdGl2ZT4gPSBbXG4gICAgICAgICdjb25maXJtVGV4dCcsXG4gICAgICAgICdjYW5jZWxUZXh0JyxcbiAgICAgICAgJ3BsYWNlbWVudCcsXG4gICAgICAgICdjb25maXJtQnV0dG9uVHlwZScsXG4gICAgICAgICdjYW5jZWxCdXR0b25UeXBlJyxcbiAgICAgICAgJ2ZvY3VzQnV0dG9uJyxcbiAgICAgICAgJ2hpZGVDb25maXJtQnV0dG9uJyxcbiAgICAgICAgJ2hpZGVDYW5jZWxCdXR0b24nLFxuICAgICAgICAncG9wb3ZlckNsYXNzJyxcbiAgICAgICAgJ2FwcGVuZFRvQm9keScsXG4gICAgICAgICdjdXN0b21UZW1wbGF0ZScsXG4gICAgICAgICdyZXZlcnNlQnV0dG9uT3JkZXInLFxuICAgICAgICAncG9wb3ZlclRpdGxlJyxcbiAgICAgICAgJ3BvcG92ZXJNZXNzYWdlJ1xuICAgICAgXTtcbiAgICAgIG9wdGlvbmFsUGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbcGFyYW1dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIChvcHRpb25zIGFzIGFueSlbcGFyYW1dID0gdGhpc1twYXJhbV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb21wb25lbnRGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFxuICAgICAgICBDb25maXJtYXRpb25Qb3BvdmVyV2luZG93Q29tcG9uZW50XG4gICAgICA+ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoQ29uZmlybWF0aW9uUG9wb3ZlcldpbmRvd0NvbXBvbmVudCk7XG4gICAgICBjb25zdCBjaGlsZEluamVjdG9yID0gSW5qZWN0b3IuY3JlYXRlKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogQ29uZmlybWF0aW9uUG9wb3ZlcldpbmRvd09wdGlvbnMsXG4gICAgICAgICAgICB1c2VWYWx1ZTogb3B0aW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yXG4gICAgICApO1xuICAgICAgdGhpcy5wb3BvdmVyID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChcbiAgICAgICAgY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLmxlbmd0aCxcbiAgICAgICAgY2hpbGRJbmplY3RvclxuICAgICAgKTtcbiAgICAgIGlmIChvcHRpb25zLmFwcGVuZFRvQm9keSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucG9wb3Zlci5sb2NhdGlvbi5uYXRpdmVFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwb3NpdGlvblBvcG92ZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucG9wb3Zlcikge1xuICAgICAgY29uc3QgcG9wb3ZlckVsZW1lbnQgPSB0aGlzLnBvcG92ZXIubG9jYXRpb24ubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgIGNvbnN0IHBvcG92ZXJQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24ucG9zaXRpb25FbGVtZW50cyhcbiAgICAgICAgdGhpcy5lbG0ubmF0aXZlRWxlbWVudCxcbiAgICAgICAgcG9wb3ZlckVsZW1lbnQsXG4gICAgICAgIHRoaXMucGxhY2VtZW50IHx8IHRoaXMuZGVmYXVsdE9wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICB0aGlzLmFwcGVuZFRvQm9keSB8fCB0aGlzLmRlZmF1bHRPcHRpb25zLmFwcGVuZFRvQm9keVxuICAgICAgKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocG9wb3ZlckVsZW1lbnQsICd0b3AnLCBgJHtwb3BvdmVyUG9zaXRpb24udG9wfXB4YCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICBwb3BvdmVyRWxlbWVudCxcbiAgICAgICAgJ2xlZnQnLFxuICAgICAgICBgJHtwb3BvdmVyUG9zaXRpb24ubGVmdH1weGBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoaWRlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wb3BvdmVyKSB7XG4gICAgICB0aGlzLnBvcG92ZXIuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIHRoaXMucG9wb3ZlcjtcbiAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBSZW5kZXJlcixcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBIGhlbHBlciBkaXJlY3RpdmUgdG8gZm9jdXMgYnV0dG9ucy4gWW91IHdpbGwgb25seSBuZWVkIHRoaXMgaWYgdXNpbmcgYSBjdXN0b20gdGVtcGxhdGVcbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW213bEZvY3VzXSdcbn0pXG5leHBvcnQgY2xhc3MgRm9jdXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBtd2xGb2N1czogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsbTogRWxlbWVudFJlZikge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubXdsRm9jdXMgJiYgdGhpcy5td2xGb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5lbG0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMsIEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUG9zaXRpb25pbmcgfSBmcm9tICdwb3NpdGlvbmluZyc7XG5pbXBvcnQgeyBDb25maXJtYXRpb25Qb3BvdmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9jb25maXJtYXRpb24tcG9wb3Zlci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ29uZmlybWF0aW9uUG9wb3ZlcldpbmRvd0NvbXBvbmVudCB9IGZyb20gJy4vY29uZmlybWF0aW9uLXBvcG92ZXItd2luZG93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGb2N1c0RpcmVjdGl2ZSB9IGZyb20gJy4vZm9jdXMuZGlyZWN0aXZlJztcbmltcG9ydCB7XG4gIENvbmZpcm1hdGlvblBvcG92ZXJPcHRpb25zLFxuICBDb25maXJtYXRpb25Qb3BvdmVyT3B0aW9uc0ludGVyZmFjZVxufSBmcm9tICcuL2NvbmZpcm1hdGlvbi1wb3BvdmVyLW9wdGlvbnMucHJvdmlkZXInO1xuXG5leHBvcnQgY29uc3QgVVNFUl9PUFRJT05TOiBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+ID0gbmV3IEluamVjdGlvblRva2VuKFxuICAnY29uZmlybWF0aW9uIHBvcG92ZXIgdXNlciBvcHRpb25zJ1xuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbnNGYWN0b3J5KFxuICB1c2VyT3B0aW9uczogQ29uZmlybWF0aW9uUG9wb3Zlck9wdGlvbnNcbik6IENvbmZpcm1hdGlvblBvcG92ZXJPcHRpb25zIHtcbiAgY29uc3Qgb3B0aW9uczogQ29uZmlybWF0aW9uUG9wb3Zlck9wdGlvbnMgPSBuZXcgQ29uZmlybWF0aW9uUG9wb3Zlck9wdGlvbnMoKTtcbiAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBDb25maXJtYXRpb25Qb3BvdmVyRGlyZWN0aXZlLFxuICAgIENvbmZpcm1hdGlvblBvcG92ZXJXaW5kb3dDb21wb25lbnQsXG4gICAgRm9jdXNEaXJlY3RpdmVcbiAgXSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IFtDb25maXJtYXRpb25Qb3BvdmVyRGlyZWN0aXZlLCBGb2N1c0RpcmVjdGl2ZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NvbmZpcm1hdGlvblBvcG92ZXJXaW5kb3dDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvblBvcG92ZXJNb2R1bGUge1xuICBzdGF0aWMgZm9yUm9vdChcbiAgICBvcHRpb25zOiBDb25maXJtYXRpb25Qb3BvdmVyT3B0aW9uc0ludGVyZmFjZSA9IHt9XG4gICk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogQ29uZmlybWF0aW9uUG9wb3Zlck1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogVVNFUl9PUFRJT05TLFxuICAgICAgICAgIHVzZVZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBDb25maXJtYXRpb25Qb3BvdmVyT3B0aW9ucyxcbiAgICAgICAgICB1c2VGYWN0b3J5OiBvcHRpb25zRmFjdG9yeSxcbiAgICAgICAgICBkZXBzOiBbVVNFUl9PUFRJT05TXVxuICAgICAgICB9LFxuICAgICAgICBQb3NpdGlvbmluZ1xuICAgICAgXVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OzJCQTRFd0IsU0FBUzswQkFDVixRQUFRO2lDQUNELFNBQVM7Z0NBQ1YsU0FBUzt5QkFDaEIsS0FBSztpQ0FFSSxLQUFLO2dDQUNOLEtBQUs7NEJBQ1YsRUFBRTs0QkFDRCxLQUFLO2tDQUNDLEtBQUs7bUNBQ0osSUFBSTs7Q0FDcEM7Ozs7OztBQ3ZGRDs7O0FBT0Esc0NBQThDLFNBQVEsMEJBQTBCOzs7WUFEL0UsVUFBVTs7Ozs7OztBQ1BYOzs7QUE4RkE7Ozs7SUFDRSxZQUFtQixPQUF5QztRQUF6QyxZQUFPLEdBQVAsT0FBTyxDQUFrQztLQUFJOzs7O0lBRWhFLGVBQWU7UUFDYixJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDO0tBQ2hDOzs7WUE3RkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxpQ0FBaUM7Z0JBQzNDLE1BQU0sRUFBRTtvQkFDTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFDRDtpQkFDQTtnQkFDRCxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNENUO2FBQ0Y7Ozs7WUE1RlEsZ0NBQWdDOzs7Ozs7O0FDRHpDOzs7Ozs7Ozs7Ozs7Ozs7O0FBa0RBOzs7Ozs7Ozs7O0lBNkhFLFlBQ1Usa0JBQ0EsS0FDQSxnQkFDQSxLQUNBLFVBQ0E7UUFMQSxxQkFBZ0IsR0FBaEIsZ0JBQWdCO1FBQ2hCLFFBQUcsR0FBSCxHQUFHO1FBQ0gsbUJBQWMsR0FBZCxjQUFjO1FBQ2QsUUFBRyxHQUFILEdBQUc7UUFDSCxhQUFRLEdBQVIsUUFBUTtRQUNSLGFBQVEsR0FBUixRQUFROzs7OzBCQXpFYSxLQUFLOzs7OztzQkFNVCxLQUFLOzs7OzRCQW1CZ0IsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDOzs7O3VCQUtoQixJQUFJLFlBQVksRUFBRTs7OztzQkFLbkIsSUFBSSxZQUFZLEVBQUU7OEJBMkIzQixFQUFFO0tBWTFDOzs7OztJQUtKLFFBQVE7UUFDTixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUMvQjs7Ozs7O0lBS0QsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxZQUFTO1lBQ2xCLElBQUksT0FBTyxXQUFRLFlBQVksS0FBSyxJQUFJLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNwQjtpQkFBTTtnQkFDTCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDcEI7U0FDRjtLQUNGOzs7OztJQUtELFdBQVc7UUFDVCxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDcEI7Ozs7OztJQUtELFNBQVMsQ0FBQyxLQUF5QjtRQUNqQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDcEI7Ozs7OztJQUtELFFBQVEsQ0FBQyxLQUF5QjtRQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDcEI7Ozs7O0lBTUQsYUFBYTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2pCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNwQjthQUFNO1lBQ0wsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO0tBQ0Y7Ozs7O0lBRU8sZUFBZSxDQUFDLEtBQVk7UUFDbEMsdUJBQU0sbUJBQW1CLEdBQUcsT0FBTyxJQUFJLENBQUMsbUJBQW1CLEtBQUssV0FBVztZQUN6RSxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQztRQUNyRSxJQUNFLElBQUksQ0FBQyxPQUFPO1lBQ1osQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztZQUM5QyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztZQUMzRCxtQkFDRixFQUFFO1lBQ0EsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCOzs7OztJQUdLLFdBQVc7UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFOzs7O1lBSXJDLFVBQVUsQ0FBQztnQkFDVCxJQUFJLENBQUMsY0FBYyxHQUFHO29CQUNwQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUMsS0FBWSxLQUNyRCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUM1QjtvQkFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLENBQUMsS0FBWSxLQUN4RCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUM1QjtvQkFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2lCQUN2RSxDQUFDO2FBQ0gsQ0FBQyxDQUFDO1lBRUgsdUJBQU0sT0FBTyxHQUFHLElBQUksZ0NBQWdDLEVBQUUsQ0FBQztZQUN2RCxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUMxQyxTQUFTLEVBQUUsQ0FBQyxLQUF5QjtvQkFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDdkI7Z0JBQ0QsUUFBUSxFQUFFLENBQUMsS0FBeUI7b0JBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3RCO2dCQUNELGVBQWUsRUFBRTtvQkFDZixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7aUJBQ3hCO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsdUJBQU0sY0FBYyxHQUE4QztnQkFDaEUsYUFBYTtnQkFDYixZQUFZO2dCQUNaLFdBQVc7Z0JBQ1gsbUJBQW1CO2dCQUNuQixrQkFBa0I7Z0JBQ2xCLGFBQWE7Z0JBQ2IsbUJBQW1CO2dCQUNuQixrQkFBa0I7Z0JBQ2xCLGNBQWM7Z0JBQ2QsY0FBYztnQkFDZCxnQkFBZ0I7Z0JBQ2hCLG9CQUFvQjtnQkFDcEIsY0FBYztnQkFDZCxnQkFBZ0I7YUFDakIsQ0FBQztZQUNGLGNBQWMsQ0FBQyxPQUFPLENBQUMsS0FBSztnQkFDMUIsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxXQUFXLEVBQUU7b0JBQ3RDLG1CQUFDLE9BQWMsR0FBRSxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3ZDO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsdUJBQU0sZ0JBQWdCLEdBRWxCLElBQUksQ0FBQyxHQUFHLENBQUMsdUJBQXVCLENBQUMsa0NBQWtDLENBQUMsQ0FBQztZQUN6RSx1QkFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FDbkM7Z0JBQ0U7b0JBQ0UsT0FBTyxFQUFFLGdDQUFnQztvQkFDekMsUUFBUSxFQUFFLE9BQU87aUJBQ2xCO2FBQ0YsRUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUNyQyxDQUFDO1lBQ0YsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUNsRCxnQkFBZ0IsRUFDaEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFDNUIsYUFBYSxDQUNkLENBQUM7WUFDRixJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3hCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ2hFO1lBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDOUI7Ozs7O0lBR0ssZUFBZTtRQUNyQixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsdUJBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkUsdUJBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQ3BELElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUN0QixjQUFjLEVBQ2QsSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFDL0MsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FDdEQsQ0FBQztZQUNGLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLGNBQWMsRUFBRSxLQUFLLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztZQUMxRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDcEIsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FDNUIsQ0FBQztTQUNIOzs7OztJQUdLLFdBQVc7UUFDakIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdkIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQ3BCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO1NBQzFCOzs7O1lBbFRKLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsMEJBQTBCO2FBQ3JDOzs7O1lBM0NDLGdCQUFnQjtZQUdoQixVQUFVO1lBV0gsMEJBQTBCO1lBUGpDLHdCQUF3QjtZQVNqQixXQUFXO1lBUmxCLFNBQVM7OzsyQkF5Q1IsS0FBSzs2QkFLTCxLQUFLOzBCQUtMLEtBQUs7eUJBS0wsS0FBSzt3QkFLTCxLQUFLO2dDQU1MLEtBQUs7K0JBTUwsS0FBSzswQkFNTCxLQUFLO2dDQUtMLEtBQUs7K0JBS0wsS0FBSzt5QkFLTCxLQUFLO3FCQU1MLEtBQUs7NkJBY0wsS0FBSzsyQkFLTCxNQUFNO3NCQUtOLE1BQU07cUJBS04sTUFBTTsyQkFLTixLQUFLOzJCQUtMLEtBQUs7aUNBS0wsS0FBSztrQ0FLTCxLQUFLOzRCQW1FTCxZQUFZLFNBQUMsT0FBTzs7Ozs7OztBQ3RPdkI7OztBQWVBOzs7O0lBR0UsWUFBb0IsR0FBZTtRQUFmLFFBQUcsR0FBSCxHQUFHLENBQVk7S0FBSTs7Ozs7SUFFdkMsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxnQkFBYSxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUksRUFBRTtZQUM5QyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNoQztLQUNGOzs7WUFaRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFlBQVk7YUFDdkI7Ozs7WUFaQyxVQUFVOzs7dUJBY1QsS0FBSzs7Ozs7OztBQ2hCUix1QkFXYSxZQUFZLEdBQTJCLElBQUksY0FBYyxDQUNwRSxtQ0FBbUMsQ0FDcEMsQ0FBQzs7Ozs7QUFFRix3QkFDRSxXQUF1QztJQUV2Qyx1QkFBTSxPQUFPLEdBQStCLElBQUksMEJBQTBCLEVBQUUsQ0FBQztJQUM3RSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNwQyxPQUFPLE9BQU8sQ0FBQztDQUNoQjtBQVlEOzs7OztJQUNFLE9BQU8sT0FBTyxDQUNaLFVBQStDLEVBQUU7UUFFakQsT0FBTztZQUNMLFFBQVEsRUFBRSx5QkFBeUI7WUFDbkMsU0FBUyxFQUFFO2dCQUNUO29CQUNFLE9BQU8sRUFBRSxZQUFZO29CQUNyQixRQUFRLEVBQUUsT0FBTztpQkFDbEI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLDBCQUEwQjtvQkFDbkMsVUFBVSxFQUFFLGNBQWM7b0JBQzFCLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQztpQkFDckI7Z0JBQ0QsV0FBVzthQUNaO1NBQ0YsQ0FBQztLQUNIOzs7WUE3QkYsUUFBUSxTQUFDO2dCQUNSLFlBQVksRUFBRTtvQkFDWiw0QkFBNEI7b0JBQzVCLGtDQUFrQztvQkFDbEMsY0FBYztpQkFDZjtnQkFDRCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7Z0JBQ3ZCLE9BQU8sRUFBRSxDQUFDLDRCQUE0QixFQUFFLGNBQWMsQ0FBQztnQkFDdkQsZUFBZSxFQUFFLENBQUMsa0NBQWtDLENBQUM7YUFDdEQ7Ozs7Ozs7Ozs7Ozs7OzsifQ==