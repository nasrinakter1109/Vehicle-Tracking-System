(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-trend', ['exports', '@angular/animations', '@angular/core', '@angular/common'], factory) :
    (factory((global['ngx-trend'] = {}),global.ng.animations,global.ng.core,global.ng.common));
}(this, (function (exports,animations,core,common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /* eslint-disable no-restricted-properties */
    /**
     * normalize
     * This lets us translate a value from one scale to another.
     *
     * @param {?} value - Our initial value to translate
     * @param {?} min - the current minimum value possible
     * @param {?} max - the current maximum value possible
     * @param {?=} scaleMin - the min value of the scale we're translating to
     * @param {?=} scaleMax - the max value of the scale we're translating to
     *
     * @return {?} the value on its new scale
     */
    function normalize(value, min, max, scaleMin, scaleMax) {
        if (scaleMin === void 0) {
            scaleMin = 0;
        }
        if (scaleMax === void 0) {
            scaleMax = 1;
        }
        // If the `min` and `max` are the same value, it means our dataset is flat.
        // For now, let's assume that flat data should be aligned to the bottom.
        if (min === max) {
            return scaleMin;
        }
        return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
    }
    /**
     * moveTo
     * the coordinate that lies at a midpoint between 2 lines, based on the radius
     *
     * @param {?} to - Our initial point
     * @param {?} from - Our final point
     * @param {?} radius - The distance away from the final point
     *
     * @return {?} an object holding the x/y coordinates of the midpoint.
     */
    function moveTo(to, from, radius) {
        /** @type {?} */
        var length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
        /** @type {?} */
        var unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
        return {
            x: from.x + unitVector.x * radius,
            y: from.y + unitVector.y * radius,
        };
    }
    /** *
     * getDistanceBetween
     * Simple formula derived from pythagoras to calculate the distance between
     * 2 points on a plane.
     *
     * \@param p1 - Our initial point
     * \@param p1.x - The x value of our initial point
     * \@param p1.y - The y value of our initial point
     * \@param p2 - Our final point
     * \@param p2.x - The x value of our final point
     * \@param p2.y - The y value of our final point
     *
     * \@return the distance between the points.
      @type {?} */
    var getDistanceBetween = function (p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    };
    /** *
     * checkForCollinearPoints
     * Figure out if the midpoint fits perfectly on a line between the two others.
     *
     * \@param p1 - Our initial point
     * \@param p1.x - The x value of our initial point
     * \@param p1.y - The y value of our initial point
     * \@param p2 - Our mid-point
     * \@param p2.x - The x value of our mid-point
     * \@param p2.y - The y value of our mid-point
     * \@param p3 - Our final point
     * \@param p3.x - The x value of our final point
     * \@param p3.y - The y value of our final point
     * \@return whether or not p2 sits on the line between p1 and p3.
      @type {?} */
    var checkForCollinearPoints = function (p1, p2, p3) {
        return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var buildLinearPath = function (data) {
        return data.reduce(function (path, point, index) {
            /** @type {?} */
            var isFirstInstruction = index === 0;
            /** @type {?} */
            var instruction = isFirstInstruction ? 'M' : 'L';
            return "" + path + instruction + " " + point.x + "," + point.y + "\n";
        }, '');
    };
    /**
     * @param {?} data
     * @param {?} radius
     * @return {?}
     */
    function buildSmoothPath(data, radius) {
        var _a = __read(data), firstPoint = _a[0], otherPoints = _a.slice(1);
        return otherPoints.reduce(function (path, point, index) {
            /** @type {?} */
            var next = otherPoints[index + 1];
            /** @type {?} */
            var prev = otherPoints[index - 1] || firstPoint;
            /** @type {?} */
            var isCollinear = next && checkForCollinearPoints(prev, point, next);
            if (!next || isCollinear) {
                // The very last line in the sequence can just be a regular line.
                return path + "\nL " + point.x + "," + point.y;
            }
            /** @type {?} */
            var distanceFromPrev = getDistanceBetween(prev, point);
            /** @type {?} */
            var distanceFromNext = getDistanceBetween(next, point);
            /** @type {?} */
            var threshold = Math.min(distanceFromPrev, distanceFromNext);
            /** @type {?} */
            var isTooCloseForRadius = threshold / 2 < radius;
            /** @type {?} */
            var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
            /** @type {?} */
            var before = moveTo(prev, point, radiusForPoint);
            /** @type {?} */
            var after = moveTo(next, point, radiusForPoint);
            return [
                path,
                "L " + before.x + "," + before.y,
                "S " + point.x + "," + point.y + " " + after.x + "," + after.y,
            ].join('\n');
        }, "M " + firstPoint.x + "," + firstPoint.y);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var generateId = function () { return Math.round(Math.random() * Math.pow(10, 16)); };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} data
     * @param {?} minX
     * @param {?} maxX
     * @param {?} minY
     * @param {?} maxY
     * @return {?}
     */
    function normalizeDataset(data, minX, maxX, minY, maxY) {
        /** @type {?} */
        var boundariesX = { min: 0, max: data.length - 1 };
        /** @type {?} */
        var boundariesY = { min: Math.min.apply(Math, __spread(data)), max: Math.max.apply(Math, __spread(data)) };
        /** @type {?} */
        var normalizedData = data.map(function (point, index) {
            return ({
                x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
                y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
            });
        });
        // According to the SVG spec, paths with a height/width of `0` can't have
        // linear gradients applied. This means that our lines are invisible when
        // the dataset is flat (eg. [0, 0, 0, 0]).
        //
        // The hacky solution is to apply a very slight offset to the first point of
        // the dataset. As ugly as it is, it's the best solution we can find (there
        // are ways within the SVG spec of changing it, but not without causing
        // breaking changes).
        if (boundariesY.min === boundariesY.max) {
            normalizedData[0].y += 0.0001;
        }
        return normalizedData;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TrendComponent = /** @class */ (function () {
        function TrendComponent() {
            this.autoDraw = false;
            this.autoDrawDuration = 2000;
            this.autoDrawEasing = 'ease';
            this.padding = 8;
            this.radius = 10;
            this.stroke = 'black';
            this.strokeLinecap = '';
            this.strokeWidth = 1;
            this.gradient = [];
            this.svgWidth = '100%';
            this.svgHeight = '25%';
            this.animationState = '';
            this.id = generateId();
            this.gradientId = "ngx-trend-vertical-gradient-" + this.id;
        }
        /**
         * @return {?}
         */
        TrendComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // We need at least 2 points to draw a graph.
                if (!this.data || this.data.length < 2) {
                    return;
                }
                /** @type {?} */
                var plainValues = this.data.map(function (point) {
                    if (typeof point === 'number') {
                        return point;
                    }
                    return point.value;
                });
                /** @type {?} */
                var viewBoxWidth = this.width || 300;
                /** @type {?} */
                var viewBoxHeight = this.height || 75;
                this.svgWidth = this.width || '100%';
                this.svgHeight = this.height || '25%';
                this.viewBox = "0 0 " + viewBoxWidth + " " + viewBoxHeight;
                /** @type {?} */
                var root = location.href.split(location.hash || '#')[0];
                this.pathStroke = (this.gradient && this.gradient.length) ? "url('" + root + "#" + this.gradientId + "')" : undefined;
                this.gradientTrimmed = this.gradient.slice().reverse().map(function (val, idx) {
                    return {
                        idx: idx,
                        stopColor: val,
                        offset: normalize(idx, 0, _this.gradient.length - 1 || 1),
                    };
                });
                /** @type {?} */
                var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
                // NOTE: Because SVGs are indexed from the top left, but most data is
                // indexed from the bottom left, we're inverting the Y min/max.
                viewBoxHeight - this.padding, this.padding);
                if (this.autoDraw && this.animationState !== 'active') {
                    this.animationState = 'inactive';
                    setTimeout(function () {
                        _this.lineLength = _this.pathEl.nativeElement.getTotalLength();
                        _this.animationState = 'active';
                    });
                }
                this.d = this.smooth
                    ? buildSmoothPath(normalizedValues, this.radius)
                    : buildLinearPath(normalizedValues);
            };
        TrendComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-trend',
                        template: "\n  <svg *ngIf=\"data && data.length >= 2\"\n    [attr.width]=\"svgWidth\"\n    [attr.height]=\"svgHeight\"\n    [attr.stroke]=\"stroke\"\n    [attr.stroke-width]=\"strokeWidth\"\n    [attr.stroke-linecap]=\"strokeLinecap\"\n    [attr.viewBox]=\"viewBox\"\n    [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n  >\n    <defs *ngIf=\"gradient && gradient.length\">\n      <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n        <stop\n          *ngFor=\"let g of gradientTrimmed;\"\n          [attr.key]=\"g.idx\"\n          [attr.offset]=\"g.offset\"\n          [attr.stop-color]=\"g.stopColor\"\n        />\n      </linearGradient>\n    </defs>\n    <path fill=\"none\" #pathEl\n      [attr.stroke]=\"pathStroke\" [attr.d]=\"d\"\n      [@pathAnimaiton]=\"{\n        value: animationState,\n        params: {\n          autoDrawDuration: autoDrawDuration,\n          autoDrawEasing: autoDrawEasing,\n          lineLength: lineLength\n        }\n      }\" />\n  </svg>\n  ",
                        animations: [
                            animations.trigger('pathAnimaiton', [
                                animations.state('inactive', animations.style({ display: 'none' })),
                                animations.transition('* => active', [
                                    animations.style({ display: 'initial' }),
                                    // We do the animation using the dash array/offset trick
                                    // https://css-tricks.com/svg-line-animation-works/
                                    animations.animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', animations.keyframes([
                                        animations.style({
                                            'stroke-dasharray': '{{ lineLength }}px',
                                            'stroke-dashoffset': '{{ lineLength }}px',
                                        }),
                                        animations.style({
                                            'stroke-dasharray': '{{ lineLength }}px',
                                            'stroke-dashoffset': 0,
                                        }),
                                    ])),
                                    // One unfortunate side-effect of the auto-draw is that the line is
                                    // actually 1 big dash, the same length as the line itself. If the
                                    // line length changes (eg. radius change, new data), that dash won't
                                    // be the same length anymore. We can fix that by removing those
                                    // properties once the auto-draw is completed.
                                    animations.style({
                                        'stroke-dashoffset': '',
                                        'stroke-dasharray': '',
                                    }),
                                ]),
                            ]),
                        ]
                    }] }
        ];
        /** @nocollapse */
        TrendComponent.ctorParameters = function () { return []; };
        TrendComponent.propDecorators = {
            data: [{ type: core.Input }],
            smooth: [{ type: core.Input }],
            autoDraw: [{ type: core.Input }],
            autoDrawDuration: [{ type: core.Input }],
            autoDrawEasing: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            padding: [{ type: core.Input }],
            radius: [{ type: core.Input }],
            stroke: [{ type: core.Input }],
            strokeLinecap: [{ type: core.Input }],
            strokeWidth: [{ type: core.Input }],
            gradient: [{ type: core.Input }],
            preserveAspectRatio: [{ type: core.Input }],
            pathEl: [{ type: core.ViewChild, args: ['pathEl',] }]
        };
        return TrendComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TrendModule = /** @class */ (function () {
        function TrendModule() {
        }
        TrendModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [TrendComponent],
                        declarations: [TrendComponent],
                    },] }
        ];
        return TrendModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.TrendComponent = TrendComponent;
    exports.TrendModule = TrendModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXRyZW5kLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbbnVsbCwibmc6Ly9uZ3gtdHJlbmQvaGVscGVycy9tYXRoLmhlbHBlcnMudHMiLCJuZzovL25neC10cmVuZC9oZWxwZXJzL0RPTS5oZWxwZXJzLnRzIiwibmc6Ly9uZ3gtdHJlbmQvaGVscGVycy9taXNjLmhlbHBlcnMudHMiLCJuZzovL25neC10cmVuZC90cmVuZC90cmVuZC5oZWxwZXJzLnRzIiwibmc6Ly9uZ3gtdHJlbmQvdHJlbmQvdHJlbmQuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtdHJlbmQvdHJlbmQvdHJlbmQubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbi8qKiBub3JtYWxpemVcbiAqIFRoaXMgbGV0cyB1cyB0cmFuc2xhdGUgYSB2YWx1ZSBmcm9tIG9uZSBzY2FsZSB0byBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE91ciBpbml0aWFsIHZhbHVlIHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIG1pbiAtIHRoZSBjdXJyZW50IG1pbmltdW0gdmFsdWUgcG9zc2libGVcbiAqIEBwYXJhbSBtYXggLSB0aGUgY3VycmVudCBtYXhpbXVtIHZhbHVlIHBvc3NpYmxlXG4gKiBAcGFyYW0gc2NhbGVNaW4gLSB0aGUgbWluIHZhbHVlIG9mIHRoZSBzY2FsZSB3ZSdyZSB0cmFuc2xhdGluZyB0b1xuICogQHBhcmFtIHNjYWxlTWF4IC0gdGhlIG1heCB2YWx1ZSBvZiB0aGUgc2NhbGUgd2UncmUgdHJhbnNsYXRpbmcgdG9cbiAqXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgb24gaXRzIG5ldyBzY2FsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKFxuICB2YWx1ZTogbnVtYmVyLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXIsXG4gIHNjYWxlTWluID0gMCxcbiAgc2NhbGVNYXggPSAxLFxuKSB7XG4gIC8vIElmIHRoZSBgbWluYCBhbmQgYG1heGAgYXJlIHRoZSBzYW1lIHZhbHVlLCBpdCBtZWFucyBvdXIgZGF0YXNldCBpcyBmbGF0LlxuICAvLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgdGhhdCBmbGF0IGRhdGEgc2hvdWxkIGJlIGFsaWduZWQgdG8gdGhlIGJvdHRvbS5cbiAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHNjYWxlTWluO1xuICB9XG5cbiAgcmV0dXJuIHNjYWxlTWluICsgKHZhbHVlIC0gbWluKSAqIChzY2FsZU1heCAtIHNjYWxlTWluKSAvIChtYXggLSBtaW4pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59XG5cbi8qKiBtb3ZlVG9cbiAqIHRoZSBjb29yZGluYXRlIHRoYXQgbGllcyBhdCBhIG1pZHBvaW50IGJldHdlZW4gMiBsaW5lcywgYmFzZWQgb24gdGhlIHJhZGl1c1xuICpcbiAqIEBwYXJhbSB0byAtIE91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gdG8ueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gdG8ueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gZnJvbSAtIE91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIGZyb20ueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIGZyb20ueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHJhZGl1cyAtIFRoZSBkaXN0YW5jZSBhd2F5IGZyb20gdGhlIGZpbmFsIHBvaW50XG4gKlxuICogQHJldHVybnMgYW4gb2JqZWN0IGhvbGRpbmcgdGhlIHgveSBjb29yZGluYXRlcyBvZiB0aGUgbWlkcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlVG8odG86IFBvaW50LCBmcm9tOiBQb2ludCwgcmFkaXVzOiBudW1iZXIpOiBQb2ludCB7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCgodG8ueCAtIGZyb20ueCkgKiAodG8ueCAtIGZyb20ueCkgKyAodG8ueSAtIGZyb20ueSkgKiAodG8ueSAtIGZyb20ueSkpO1xuICBjb25zdCB1bml0VmVjdG9yID0geyB4OiAodG8ueCAtIGZyb20ueCkgLyBsZW5ndGgsIHk6ICh0by55IC0gZnJvbS55KSAvIGxlbmd0aCB9O1xuXG4gIHJldHVybiB7XG4gICAgeDogZnJvbS54ICsgdW5pdFZlY3Rvci54ICogcmFkaXVzLFxuICAgIHk6IGZyb20ueSArIHVuaXRWZWN0b3IueSAqIHJhZGl1cyxcbiAgfTtcbn1cblxuLyoqIGdldERpc3RhbmNlQmV0d2VlblxuICogU2ltcGxlIGZvcm11bGEgZGVyaXZlZCBmcm9tIHB5dGhhZ29yYXMgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG4gKiAyIHBvaW50cyBvbiBhIHBsYW5lLlxuICpcbiAqIEBwYXJhbSBwMSAtIE91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDEueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDEueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDIgLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMi54IC0gVGhlIHggdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDIueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICpcbiAqIEByZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXREaXN0YW5jZUJldHdlZW4gPSAocDE6IFBvaW50LCBwMjogUG9pbnQpID0+XG4gIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpO1xuXG4vKiogY2hlY2tGb3JDb2xsaW5lYXJQb2ludHNcbiAqIEZpZ3VyZSBvdXQgaWYgdGhlIG1pZHBvaW50IGZpdHMgcGVyZmVjdGx5IG9uIGEgbGluZSBiZXR3ZWVuIHRoZSB0d28gb3RoZXJzLlxuICpcbiAqIEBwYXJhbSBwMSAtIE91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDEueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDEueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBpbml0aWFsIHBvaW50XG4gKiBAcGFyYW0gcDIgLSBPdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDIueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMi55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAzIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDMueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAzLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcblxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgcDIgc2l0cyBvbiB0aGUgbGluZSBiZXR3ZWVuIHAxIGFuZCBwMy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzID0gKHAxOiBQb2ludCwgcDI6IFBvaW50LCBwMzogUG9pbnQpID0+XG4gIChwMS55IC0gcDIueSkgKiAocDEueCAtIHAzLngpID09PSAocDEueSAtIHAzLnkpICogKHAxLnggLSBwMi54KTtcbiIsImltcG9ydCB7XG4gIGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzLFxuICBnZXREaXN0YW5jZUJldHdlZW4sXG4gIG1vdmVUbyxcbiAgUG9pbnQsXG59IGZyb20gJy4vbWF0aC5oZWxwZXJzJztcblxuZXhwb3J0IGNvbnN0IGJ1aWxkTGluZWFyUGF0aCA9IChkYXRhOiBQb2ludFtdKSA9PlxuICBkYXRhLnJlZHVjZSgocGF0aCwgcG9pbnQsIGluZGV4KSA9PiB7XG4gICAgLy8gVGhlIHZlcnkgZmlyc3QgaW5zdHJ1Y3Rpb24gbmVlZHMgdG8gYmUgYSBcIm1vdmVcIi5cbiAgICAvLyBUaGUgcmVzdCB3aWxsIGJlIGEgXCJsaW5lXCIuXG4gICAgY29uc3QgaXNGaXJzdEluc3RydWN0aW9uID0gaW5kZXggPT09IDA7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBpc0ZpcnN0SW5zdHJ1Y3Rpb24gPyAnTScgOiAnTCc7XG5cbiAgICByZXR1cm4gYCR7cGF0aH0ke2luc3RydWN0aW9ufSAke3BvaW50Lnh9LCR7cG9pbnQueX1cXG5gO1xuICB9LCAnJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNtb290aFBhdGgoZGF0YTogUG9pbnRbXSwgcmFkaXVzOiBudW1iZXIpIHtcbiAgY29uc3QgW2ZpcnN0UG9pbnQsIC4uLm90aGVyUG9pbnRzXSA9IGRhdGE7XG5cbiAgcmV0dXJuIG90aGVyUG9pbnRzLnJlZHVjZSgocGF0aCwgcG9pbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbmV4dCA9IG90aGVyUG9pbnRzW2luZGV4ICsgMV07XG4gICAgY29uc3QgcHJldiA9IG90aGVyUG9pbnRzW2luZGV4IC0gMV0gfHwgZmlyc3RQb2ludDtcblxuICAgIGNvbnN0IGlzQ29sbGluZWFyID0gbmV4dCAmJiBjaGVja0ZvckNvbGxpbmVhclBvaW50cyhwcmV2LCBwb2ludCwgbmV4dCk7XG5cbiAgICBpZiAoIW5leHQgfHwgaXNDb2xsaW5lYXIpIHtcbiAgICAgIC8vIFRoZSB2ZXJ5IGxhc3QgbGluZSBpbiB0aGUgc2VxdWVuY2UgY2FuIGp1c3QgYmUgYSByZWd1bGFyIGxpbmUuXG4gICAgICByZXR1cm4gYCR7cGF0aH1cXG5MICR7cG9pbnQueH0sJHtwb2ludC55fWA7XG4gICAgfVxuXG4gICAgY29uc3QgZGlzdGFuY2VGcm9tUHJldiA9IGdldERpc3RhbmNlQmV0d2VlbihwcmV2LCBwb2ludCk7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tTmV4dCA9IGdldERpc3RhbmNlQmV0d2VlbihuZXh0LCBwb2ludCk7XG4gICAgY29uc3QgdGhyZXNob2xkID0gTWF0aC5taW4oZGlzdGFuY2VGcm9tUHJldiwgZGlzdGFuY2VGcm9tTmV4dCk7XG5cbiAgICBjb25zdCBpc1Rvb0Nsb3NlRm9yUmFkaXVzID0gdGhyZXNob2xkIC8gMiA8IHJhZGl1cztcblxuICAgIGNvbnN0IHJhZGl1c0ZvclBvaW50ID0gaXNUb29DbG9zZUZvclJhZGl1cyA/IHRocmVzaG9sZCAvIDIgOiByYWRpdXM7XG5cbiAgICBjb25zdCBiZWZvcmUgPSBtb3ZlVG8ocHJldiwgcG9pbnQsIHJhZGl1c0ZvclBvaW50KTtcbiAgICBjb25zdCBhZnRlciA9IG1vdmVUbyhuZXh0LCBwb2ludCwgcmFkaXVzRm9yUG9pbnQpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHBhdGgsXG4gICAgICBgTCAke2JlZm9yZS54fSwke2JlZm9yZS55fWAsXG4gICAgICBgUyAke3BvaW50Lnh9LCR7cG9pbnQueX0gJHthZnRlci54fSwke2FmdGVyLnl9YCxcbiAgICBdLmpvaW4oJ1xcbicpO1xuICB9LCBgTSAke2ZpcnN0UG9pbnQueH0sJHtmaXJzdFBvaW50Lnl9YCk7XG59XG4iLCJleHBvcnQgY29uc3QgZ2VuZXJhdGVJZCA9ICgpID0+IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDEwLCAxNikpO1xuIiwiaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vaGVscGVycy9tYXRoLmhlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRGF0YXNldChcbiAgZGF0YTogbnVtYmVyW10sXG4gIG1pblg6IG51bWJlcixcbiAgbWF4WDogbnVtYmVyLFxuICBtaW5ZOiBudW1iZXIsXG4gIG1heFk6IG51bWJlcixcbikge1xuICAvLyBGb3IgdGhlIFggYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gaXRzIGluZGV4IGluIHRoZSBhcnJheS5cbiAgLy8gRm9yIHRoZSBZIGF4aXMsIHdlIHdhbnQgdG8gbm9ybWFsaXplIGl0IGJhc2VkIG9uIHRoZSBlbGVtZW50J3MgdmFsdWUuXG4gIC8vXG4gIC8vIFggYXhpcyBpcyBlYXN5OiBqdXN0IGV2ZW5seS1zcGFjZSBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2UgZmlyc3QgbmVlZCB0byBmaW5kIHRoZSBtaW4gYW5kIG1heCBvZiBvdXIgYXJyYXksXG4gIC8vIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aG9zZSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLlxuICBjb25zdCBib3VuZGFyaWVzWCA9IHsgbWluOiAwLCBtYXg6IGRhdGEubGVuZ3RoIC0gMSB9O1xuICBjb25zdCBib3VuZGFyaWVzWSA9IHsgbWluOiBNYXRoLm1pbiguLi5kYXRhKSwgbWF4OiBNYXRoLm1heCguLi5kYXRhKSB9O1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWREYXRhID0gZGF0YS5tYXAoKHBvaW50LCBpbmRleCkgPT4gKHtcbiAgICB4OiBub3JtYWxpemUoaW5kZXgsIGJvdW5kYXJpZXNYLm1pbiwgYm91bmRhcmllc1gubWF4LCBtaW5YLCBtYXhYKSxcbiAgICB5OiBub3JtYWxpemUocG9pbnQsIGJvdW5kYXJpZXNZLm1pbiwgYm91bmRhcmllc1kubWF4LCBtaW5ZLCBtYXhZKSxcbiAgfSkpO1xuXG4gIC8vIEFjY29yZGluZyB0byB0aGUgU1ZHIHNwZWMsIHBhdGhzIHdpdGggYSBoZWlnaHQvd2lkdGggb2YgYDBgIGNhbid0IGhhdmVcbiAgLy8gbGluZWFyIGdyYWRpZW50cyBhcHBsaWVkLiBUaGlzIG1lYW5zIHRoYXQgb3VyIGxpbmVzIGFyZSBpbnZpc2libGUgd2hlblxuICAvLyB0aGUgZGF0YXNldCBpcyBmbGF0IChlZy4gWzAsIDAsIDAsIDBdKS5cbiAgLy9cbiAgLy8gVGhlIGhhY2t5IHNvbHV0aW9uIGlzIHRvIGFwcGx5IGEgdmVyeSBzbGlnaHQgb2Zmc2V0IHRvIHRoZSBmaXJzdCBwb2ludCBvZlxuICAvLyB0aGUgZGF0YXNldC4gQXMgdWdseSBhcyBpdCBpcywgaXQncyB0aGUgYmVzdCBzb2x1dGlvbiB3ZSBjYW4gZmluZCAodGhlcmVcbiAgLy8gYXJlIHdheXMgd2l0aGluIHRoZSBTVkcgc3BlYyBvZiBjaGFuZ2luZyBpdCwgYnV0IG5vdCB3aXRob3V0IGNhdXNpbmdcbiAgLy8gYnJlYWtpbmcgY2hhbmdlcykuXG4gIGlmIChib3VuZGFyaWVzWS5taW4gPT09IGJvdW5kYXJpZXNZLm1heCkge1xuICAgIG5vcm1hbGl6ZWREYXRhWzBdLnkgKz0gMC4wMDAxO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWREYXRhO1xufVxuIiwiaW1wb3J0IHtcbiAgYW5pbWF0ZSxcbiAga2V5ZnJhbWVzLFxuICBzdGF0ZSxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb24sXG4gIHRyaWdnZXIsXG59IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBWaWV3Q2hpbGQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBidWlsZExpbmVhclBhdGgsIGJ1aWxkU21vb3RoUGF0aCB9IGZyb20gJy4uL2hlbHBlcnMvRE9NLmhlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vaGVscGVycy9tYXRoLmhlbHBlcnMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL2hlbHBlcnMvbWlzYy5oZWxwZXJzJztcbmltcG9ydCB7IG5vcm1hbGl6ZURhdGFzZXQgfSBmcm9tICcuL3RyZW5kLmhlbHBlcnMnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25neC10cmVuZCcsXG4gIHRlbXBsYXRlOiBgXG4gIDxzdmcgKm5nSWY9XCJkYXRhICYmIGRhdGEubGVuZ3RoID49IDJcIlxuICAgIFthdHRyLndpZHRoXT1cInN2Z1dpZHRoXCJcbiAgICBbYXR0ci5oZWlnaHRdPVwic3ZnSGVpZ2h0XCJcbiAgICBbYXR0ci5zdHJva2VdPVwic3Ryb2tlXCJcbiAgICBbYXR0ci5zdHJva2Utd2lkdGhdPVwic3Ryb2tlV2lkdGhcIlxuICAgIFthdHRyLnN0cm9rZS1saW5lY2FwXT1cInN0cm9rZUxpbmVjYXBcIlxuICAgIFthdHRyLnZpZXdCb3hdPVwidmlld0JveFwiXG4gICAgW2F0dHIucHJlc2VydmVBc3BlY3RSYXRpb109XCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCJcbiAgPlxuICAgIDxkZWZzICpuZ0lmPVwiZ3JhZGllbnQgJiYgZ3JhZGllbnQubGVuZ3RoXCI+XG4gICAgICA8bGluZWFyR3JhZGllbnQgW2F0dHIuaWRdPVwiZ3JhZGllbnRJZFwiIHgxPVwiMCVcIiB5MT1cIjAlXCIgeDI9XCIwJVwiIHkyPVwiMTAwJVwiPlxuICAgICAgICA8c3RvcFxuICAgICAgICAgICpuZ0Zvcj1cImxldCBnIG9mIGdyYWRpZW50VHJpbW1lZDtcIlxuICAgICAgICAgIFthdHRyLmtleV09XCJnLmlkeFwiXG4gICAgICAgICAgW2F0dHIub2Zmc2V0XT1cImcub2Zmc2V0XCJcbiAgICAgICAgICBbYXR0ci5zdG9wLWNvbG9yXT1cImcuc3RvcENvbG9yXCJcbiAgICAgICAgLz5cbiAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgPC9kZWZzPlxuICAgIDxwYXRoIGZpbGw9XCJub25lXCIgI3BhdGhFbFxuICAgICAgW2F0dHIuc3Ryb2tlXT1cInBhdGhTdHJva2VcIiBbYXR0ci5kXT1cImRcIlxuICAgICAgW0BwYXRoQW5pbWFpdG9uXT1cIntcbiAgICAgICAgdmFsdWU6IGFuaW1hdGlvblN0YXRlLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBhdXRvRHJhd0R1cmF0aW9uOiBhdXRvRHJhd0R1cmF0aW9uLFxuICAgICAgICAgIGF1dG9EcmF3RWFzaW5nOiBhdXRvRHJhd0Vhc2luZyxcbiAgICAgICAgICBsaW5lTGVuZ3RoOiBsaW5lTGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cIiAvPlxuICA8L3N2Zz5cbiAgYCxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ3BhdGhBbmltYWl0b24nLCBbXG4gICAgICBzdGF0ZSgnaW5hY3RpdmUnLCBzdHlsZSh7IGRpc3BsYXk6ICdub25lJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IGFjdGl2ZScsIFtcbiAgICAgICAgc3R5bGUoeyBkaXNwbGF5OiAnaW5pdGlhbCcgfSksXG4gICAgICAgIC8vIFdlIGRvIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIGRhc2ggYXJyYXkvb2Zmc2V0IHRyaWNrXG4gICAgICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc3ZnLWxpbmUtYW5pbWF0aW9uLXdvcmtzL1xuICAgICAgICBhbmltYXRlKCd7eyBhdXRvRHJhd0R1cmF0aW9uIH19bXMge3sgYXV0b0RyYXdFYXNpbmcgfX0nLFxuICAgICAgICAgIGtleWZyYW1lcyhbXG4gICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6IDAsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgKSxcbiAgICAgICAgLy8gT25lIHVuZm9ydHVuYXRlIHNpZGUtZWZmZWN0IG9mIHRoZSBhdXRvLWRyYXcgaXMgdGhhdCB0aGUgbGluZSBpc1xuICAgICAgICAvLyBhY3R1YWxseSAxIGJpZyBkYXNoLCB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGxpbmUgaXRzZWxmLiBJZiB0aGVcbiAgICAgICAgLy8gbGluZSBsZW5ndGggY2hhbmdlcyAoZWcuIHJhZGl1cyBjaGFuZ2UsIG5ldyBkYXRhKSwgdGhhdCBkYXNoIHdvbid0XG4gICAgICAgIC8vIGJlIHRoZSBzYW1lIGxlbmd0aCBhbnltb3JlLiBXZSBjYW4gZml4IHRoYXQgYnkgcmVtb3ZpbmcgdGhvc2VcbiAgICAgICAgLy8gcHJvcGVydGllcyBvbmNlIHRoZSBhdXRvLWRyYXcgaXMgY29tcGxldGVkLlxuICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJycsXG4gICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnJyxcbiAgICAgICAgfSksXG4gICAgICBdKSxcbiAgICBdKSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJlbmRDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBpZDogbnVtYmVyO1xuICBASW5wdXQoKSBkYXRhOiAobnVtYmVyIHwge3ZhbHVlOiBudW1iZXJ9KVtdO1xuICBASW5wdXQoKSBzbW9vdGg6IGJvb2xlYW47XG4gIEBJbnB1dCgpIGF1dG9EcmF3ID0gZmFsc2U7XG4gIEBJbnB1dCgpIGF1dG9EcmF3RHVyYXRpb24gPSAyMDAwO1xuICBASW5wdXQoKSBhdXRvRHJhd0Vhc2luZyA9ICdlYXNlJztcbiAgQElucHV0KCkgd2lkdGg6IG51bWJlcjtcbiAgQElucHV0KCkgaGVpZ2h0OiBudW1iZXI7XG4gIEBJbnB1dCgpIHBhZGRpbmcgPSA4O1xuICBASW5wdXQoKSByYWRpdXMgPSAxMDtcbiAgQElucHV0KCkgc3Ryb2tlID0gJ2JsYWNrJztcbiAgQElucHV0KCkgc3Ryb2tlTGluZWNhcCA9ICcnO1xuICBASW5wdXQoKSBzdHJva2VXaWR0aCA9IDE7XG4gIEBJbnB1dCgpIGdyYWRpZW50OiBzdHJpbmdbXSA9IFtdO1xuICBASW5wdXQoKSBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBzdHJpbmc7XG4gIEBWaWV3Q2hpbGQoJ3BhdGhFbCcpIHBhdGhFbDogRWxlbWVudFJlZjtcbiAgZ3JhZGllbnRUcmltbWVkOiBhbnlbXTtcbiAgZDogYW55O1xuICBzdmdXaWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzEwMCUnO1xuICBzdmdIZWlnaHQ6IHN0cmluZyB8IG51bWJlciA9ICcyNSUnO1xuICB2aWV3Qm94OiBzdHJpbmc7XG4gIHBhdGhTdHJva2U6IGFueTtcbiAgZ3JhZGllbnRJZDogc3RyaW5nO1xuICBsaW5lTGVuZ3RoOiBudW1iZXI7XG4gIGFuaW1hdGlvblN0YXRlID0gJyc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICB0aGlzLmdyYWRpZW50SWQgPSBgbmd4LXRyZW5kLXZlcnRpY2FsLWdyYWRpZW50LSR7dGhpcy5pZH1gO1xuICB9XG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIC8vIFdlIG5lZWQgYXQgbGVhc3QgMiBwb2ludHMgdG8gZHJhdyBhIGdyYXBoLlxuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYGRhdGFgIGNhbiBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbnVtYmVyczpcbiAgICAvLyBbMSwgMiwgM11cbiAgICAvLyBvciwgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgdmFsdWU6XG4gICAgLy8gW3sgdmFsdWU6IDEgfSwgeyB2YWx1ZTogMiB9LCB7IHZhbHVlOiAzIH1dXG4gICAgLy9cbiAgICAvLyBGb3Igbm93LCB3ZSdyZSBqdXN0IGdvaW5nIHRvIGNvbnZlcnQgdGhlIHNlY29uZCBmb3JtIHRvIHRoZSBmaXJzdC5cbiAgICAvLyBMYXRlciBvbiwgaWYvd2hlbiB3ZSBzdXBwb3J0IHRvb2x0aXBzLCB3ZSBtYXkgYWRqdXN0LlxuICAgIGNvbnN0IHBsYWluVmFsdWVzID0gdGhpcy5kYXRhLm1hcCgocG9pbnQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludC52YWx1ZTtcbiAgICB9KTtcblxuICAgIC8vIE91ciB2aWV3Ym94IG5lZWRzIHRvIGJlIGluIGFic29sdXRlIHVuaXRzLCBzbyB3ZSdsbCBkZWZhdWx0IHRvIDMwMHg3NVxuICAgIC8vIE91ciBTVkcgY2FuIGJlIGEgJSwgdGhvdWdoOyB0aGlzIGlzIHdoYXQgbWFrZXMgaXQgc2NhbGFibGUuXG4gICAgLy8gQnkgZGVmYXVsdGluZyB0byBwZXJjZW50YWdlcywgdGhlIFNWRyB3aWxsIGdyb3cgdG8gZmlsbCBpdHMgcGFyZW50XG4gICAgLy8gY29udGFpbmVyLCBwcmVzZXJ2aW5nIGEgMS80IGFzcGVjdCByYXRpby5cbiAgICBjb25zdCB2aWV3Qm94V2lkdGggPSB0aGlzLndpZHRoIHx8IDMwMDtcbiAgICBjb25zdCB2aWV3Qm94SGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgNzU7XG4gICAgdGhpcy5zdmdXaWR0aCA9IHRoaXMud2lkdGggfHwgJzEwMCUnO1xuICAgIHRoaXMuc3ZnSGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgJzI1JSc7XG4gICAgdGhpcy52aWV3Qm94ID0gYDAgMCAke3ZpZXdCb3hXaWR0aH0gJHt2aWV3Qm94SGVpZ2h0fWA7XG4gICAgY29uc3Qgcm9vdCA9IGxvY2F0aW9uLmhyZWYuc3BsaXQobG9jYXRpb24uaGFzaCB8fCAnIycpWzBdO1xuICAgIHRoaXMucGF0aFN0cm9rZSA9ICh0aGlzLmdyYWRpZW50ICYmIHRoaXMuZ3JhZGllbnQubGVuZ3RoKSA/IGB1cmwoJyR7cm9vdH0jJHt0aGlzLmdyYWRpZW50SWR9JylgIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5ncmFkaWVudFRyaW1tZWQgPSB0aGlzLmdyYWRpZW50LnNsaWNlKCkucmV2ZXJzZSgpLm1hcCgodmFsLCBpZHgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkeCxcbiAgICAgICAgc3RvcENvbG9yOiB2YWwsXG4gICAgICAgIG9mZnNldDogbm9ybWFsaXplKGlkeCwgMCwgdGhpcy5ncmFkaWVudC5sZW5ndGggLSAxIHx8IDEpLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBub3JtYWxpemVEYXRhc2V0KHBsYWluVmFsdWVzLFxuICAgICAgdGhpcy5wYWRkaW5nLFxuICAgICAgdmlld0JveFdpZHRoIC0gdGhpcy5wYWRkaW5nLFxuICAgICAgLy8gTk9URTogQmVjYXVzZSBTVkdzIGFyZSBpbmRleGVkIGZyb20gdGhlIHRvcCBsZWZ0LCBidXQgbW9zdCBkYXRhIGlzXG4gICAgICAvLyBpbmRleGVkIGZyb20gdGhlIGJvdHRvbSBsZWZ0LCB3ZSdyZSBpbnZlcnRpbmcgdGhlIFkgbWluL21heC5cbiAgICAgIHZpZXdCb3hIZWlnaHQgLSB0aGlzLnBhZGRpbmcsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmF1dG9EcmF3ICYmIHRoaXMuYW5pbWF0aW9uU3RhdGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ2luYWN0aXZlJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSB0aGlzLnBhdGhFbC5uYXRpdmVFbGVtZW50LmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnYWN0aXZlJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZCA9IHRoaXMuc21vb3RoXG4gICAgICA/IGJ1aWxkU21vb3RoUGF0aChub3JtYWxpemVkVmFsdWVzLCB0aGlzLnJhZGl1cylcbiAgICAgIDogYnVpbGRMaW5lYXJQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVHJlbmRDb21wb25lbnQgfSBmcm9tICcuL3RyZW5kLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBleHBvcnRzOiBbVHJlbmRDb21wb25lbnRdLFxuICBkZWNsYXJhdGlvbnM6IFtUcmVuZENvbXBvbmVudF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyZW5kTW9kdWxlIHtcbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJ0cmlnZ2VyIiwic3RhdGUiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJhbmltYXRlIiwia2V5ZnJhbWVzIiwiSW5wdXQiLCJWaWV3Q2hpbGQiLCJOZ01vZHVsZSIsIkNvbW1vbk1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7O0FBY0Esb0JBdUd1QixDQUFDLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsR0FB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