/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { checkForCollinearPoints, getDistanceBetween, moveTo, } from './math.helpers';
/** @type {?} */
export var buildLinearPath = function (data) {
    return data.reduce(function (path, point, index) {
        /** @type {?} */
        var isFirstInstruction = index === 0;
        /** @type {?} */
        var instruction = isFirstInstruction ? 'M' : 'L';
        return "" + path + instruction + " " + point.x + "," + point.y + "\n";
    }, '');
};
/**
 * @param {?} data
 * @param {?} radius
 * @return {?}
 */
export function buildSmoothPath(data, radius) {
    var _a = tslib_1.__read(data), firstPoint = _a[0], otherPoints = _a.slice(1);
    return otherPoints.reduce(function (path, point, index) {
        /** @type {?} */
        var next = otherPoints[index + 1];
        /** @type {?} */
        var prev = otherPoints[index - 1] || firstPoint;
        /** @type {?} */
        var isCollinear = next && checkForCollinearPoints(prev, point, next);
        if (!next || isCollinear) {
            // The very last line in the sequence can just be a regular line.
            return path + "\nL " + point.x + "," + point.y;
        }
        /** @type {?} */
        var distanceFromPrev = getDistanceBetween(prev, point);
        /** @type {?} */
        var distanceFromNext = getDistanceBetween(next, point);
        /** @type {?} */
        var threshold = Math.min(distanceFromPrev, distanceFromNext);
        /** @type {?} */
        var isTooCloseForRadius = threshold / 2 < radius;
        /** @type {?} */
        var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
        /** @type {?} */
        var before = moveTo(prev, point, radiusForPoint);
        /** @type {?} */
        var after = moveTo(next, point, radiusForPoint);
        return [
            path,
            "L " + before.x + "," + before.y,
            "S " + point.x + "," + point.y + " " + after.x + "," + after.y,
        ].join('\n');
    }, "M " + firstPoint.x + "," + firstPoint.y);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRE9NLmhlbHBlcnMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtdHJlbmQvIiwic291cmNlcyI6WyJoZWxwZXJzL0RPTS5oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixrQkFBa0IsRUFDbEIsTUFBTSxHQUVQLE1BQU0sZ0JBQWdCLENBQUM7O0FBRXhCLFdBQWEsZUFBZSxHQUFHLFVBQUMsSUFBYTtJQUMzQyxPQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUs7O1FBRzdCLElBQU0sa0JBQWtCLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQzs7UUFDdkMsSUFBTSxXQUFXLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBRW5ELE9BQU8sS0FBRyxJQUFJLEdBQUcsV0FBVyxTQUFJLEtBQUssQ0FBQyxDQUFDLFNBQUksS0FBSyxDQUFDLENBQUMsT0FBSSxDQUFDO0tBQ3hELEVBQUUsRUFBRSxDQUFDO0FBUE4sQ0FPTSxDQUFDOzs7Ozs7QUFFVCxNQUFNLDBCQUEwQixJQUFhLEVBQUUsTUFBYztJQUMzRCwrQkFBTyxrQkFBVSxFQUFFLHlCQUFjLENBQVM7SUFFMUMsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLOztRQUMzQyxJQUFNLElBQUksR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDOztRQUNwQyxJQUFNLElBQUksR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQzs7UUFFbEQsSUFBTSxXQUFXLEdBQUcsSUFBSSxJQUFJLHVCQUF1QixDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFdkUsSUFBSSxDQUFDLElBQUksSUFBSSxXQUFXLEVBQUU7O1lBRXhCLE9BQVUsSUFBSSxZQUFPLEtBQUssQ0FBQyxDQUFDLFNBQUksS0FBSyxDQUFDLENBQUcsQ0FBQztTQUMzQzs7UUFFRCxJQUFNLGdCQUFnQixHQUFHLGtCQUFrQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQzs7UUFDekQsSUFBTSxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7O1FBQ3pELElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzs7UUFFL0QsSUFBTSxtQkFBbUIsR0FBRyxTQUFTLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQzs7UUFFbkQsSUFBTSxjQUFjLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQzs7UUFFcEUsSUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsY0FBYyxDQUFDLENBQUM7O1FBQ25ELElBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRWxELE9BQU87WUFDTCxJQUFJO1lBQ0osT0FBSyxNQUFNLENBQUMsQ0FBQyxTQUFJLE1BQU0sQ0FBQyxDQUFHO1lBQzNCLE9BQUssS0FBSyxDQUFDLENBQUMsU0FBSSxLQUFLLENBQUMsQ0FBQyxTQUFJLEtBQUssQ0FBQyxDQUFDLFNBQUksS0FBSyxDQUFDLENBQUc7U0FDaEQsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDZCxFQUFFLE9BQUssVUFBVSxDQUFDLENBQUMsU0FBSSxVQUFVLENBQUMsQ0FBRyxDQUFDLENBQUM7Q0FDekMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjaGVja0ZvckNvbGxpbmVhclBvaW50cyxcbiAgZ2V0RGlzdGFuY2VCZXR3ZWVuLFxuICBtb3ZlVG8sXG4gIFBvaW50LFxufSBmcm9tICcuL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBidWlsZExpbmVhclBhdGggPSAoZGF0YTogUG9pbnRbXSkgPT5cbiAgZGF0YS5yZWR1Y2UoKHBhdGgsIHBvaW50LCBpbmRleCkgPT4ge1xuICAgIC8vIFRoZSB2ZXJ5IGZpcnN0IGluc3RydWN0aW9uIG5lZWRzIHRvIGJlIGEgXCJtb3ZlXCIuXG4gICAgLy8gVGhlIHJlc3Qgd2lsbCBiZSBhIFwibGluZVwiLlxuICAgIGNvbnN0IGlzRmlyc3RJbnN0cnVjdGlvbiA9IGluZGV4ID09PSAwO1xuICAgIGNvbnN0IGluc3RydWN0aW9uID0gaXNGaXJzdEluc3RydWN0aW9uID8gJ00nIDogJ0wnO1xuXG4gICAgcmV0dXJuIGAke3BhdGh9JHtpbnN0cnVjdGlvbn0gJHtwb2ludC54fSwke3BvaW50Lnl9XFxuYDtcbiAgfSwgJycpO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTbW9vdGhQYXRoKGRhdGE6IFBvaW50W10sIHJhZGl1czogbnVtYmVyKSB7XG4gIGNvbnN0IFtmaXJzdFBvaW50LCAuLi5vdGhlclBvaW50c10gPSBkYXRhO1xuXG4gIHJldHVybiBvdGhlclBvaW50cy5yZWR1Y2UoKHBhdGgsIHBvaW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBvdGhlclBvaW50c1tpbmRleCArIDFdO1xuICAgIGNvbnN0IHByZXYgPSBvdGhlclBvaW50c1tpbmRleCAtIDFdIHx8IGZpcnN0UG9pbnQ7XG5cbiAgICBjb25zdCBpc0NvbGxpbmVhciA9IG5leHQgJiYgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMocHJldiwgcG9pbnQsIG5leHQpO1xuXG4gICAgaWYgKCFuZXh0IHx8IGlzQ29sbGluZWFyKSB7XG4gICAgICAvLyBUaGUgdmVyeSBsYXN0IGxpbmUgaW4gdGhlIHNlcXVlbmNlIGNhbiBqdXN0IGJlIGEgcmVndWxhciBsaW5lLlxuICAgICAgcmV0dXJuIGAke3BhdGh9XFxuTCAke3BvaW50Lnh9LCR7cG9pbnQueX1gO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlRnJvbVByZXYgPSBnZXREaXN0YW5jZUJldHdlZW4ocHJldiwgcG9pbnQpO1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbU5leHQgPSBnZXREaXN0YW5jZUJldHdlZW4obmV4dCwgcG9pbnQpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IE1hdGgubWluKGRpc3RhbmNlRnJvbVByZXYsIGRpc3RhbmNlRnJvbU5leHQpO1xuXG4gICAgY29uc3QgaXNUb29DbG9zZUZvclJhZGl1cyA9IHRocmVzaG9sZCAvIDIgPCByYWRpdXM7XG5cbiAgICBjb25zdCByYWRpdXNGb3JQb2ludCA9IGlzVG9vQ2xvc2VGb3JSYWRpdXMgPyB0aHJlc2hvbGQgLyAyIDogcmFkaXVzO1xuXG4gICAgY29uc3QgYmVmb3JlID0gbW92ZVRvKHByZXYsIHBvaW50LCByYWRpdXNGb3JQb2ludCk7XG4gICAgY29uc3QgYWZ0ZXIgPSBtb3ZlVG8obmV4dCwgcG9pbnQsIHJhZGl1c0ZvclBvaW50KTtcblxuICAgIHJldHVybiBbXG4gICAgICBwYXRoLFxuICAgICAgYEwgJHtiZWZvcmUueH0sJHtiZWZvcmUueX1gLFxuICAgICAgYFMgJHtwb2ludC54fSwke3BvaW50Lnl9ICR7YWZ0ZXIueH0sJHthZnRlci55fWAsXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgfSwgYE0gJHtmaXJzdFBvaW50Lnh9LCR7Zmlyc3RQb2ludC55fWApO1xufVxuIl19