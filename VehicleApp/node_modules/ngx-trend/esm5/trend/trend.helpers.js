/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { normalize } from '../helpers/math.helpers';
/**
 * @param {?} data
 * @param {?} minX
 * @param {?} maxX
 * @param {?} minY
 * @param {?} maxY
 * @return {?}
 */
export function normalizeDataset(data, minX, maxX, minY, maxY) {
    /** @type {?} */
    var boundariesX = { min: 0, max: data.length - 1 };
    /** @type {?} */
    var boundariesY = { min: Math.min.apply(Math, tslib_1.__spread(data)), max: Math.max.apply(Math, tslib_1.__spread(data)) };
    /** @type {?} */
    var normalizedData = data.map(function (point, index) { return ({
        x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
        y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
    }); });
    // According to the SVG spec, paths with a height/width of `0` can't have
    // linear gradients applied. This means that our lines are invisible when
    // the dataset is flat (eg. [0, 0, 0, 0]).
    //
    // The hacky solution is to apply a very slight offset to the first point of
    // the dataset. As ugly as it is, it's the best solution we can find (there
    // are ways within the SVG spec of changing it, but not without causing
    // breaking changes).
    if (boundariesY.min === boundariesY.max) {
        normalizedData[0].y += 0.0001;
    }
    return normalizedData;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC10cmVuZC8iLCJzb3VyY2VzIjpbInRyZW5kL3RyZW5kLmhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7OztBQUVwRCxNQUFNLDJCQUNKLElBQWMsRUFDZCxJQUFZLEVBQ1osSUFBWSxFQUNaLElBQVksRUFDWixJQUFZOztJQVFaLElBQU0sV0FBVyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQzs7SUFDckQsSUFBTSxXQUFXLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsT0FBUixJQUFJLG1CQUFRLElBQUksRUFBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxPQUFSLElBQUksbUJBQVEsSUFBSSxFQUFDLEVBQUUsQ0FBQzs7SUFFdkUsSUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFDLEtBQUssRUFBRSxLQUFLLElBQUssT0FBQSxDQUFDO1FBQ2pELENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO1FBQ2pFLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO0tBQ2xFLENBQUMsRUFIZ0QsQ0FHaEQsQ0FBQyxDQUFDOzs7Ozs7Ozs7SUFVSixJQUFJLFdBQVcsQ0FBQyxHQUFHLEtBQUssV0FBVyxDQUFDLEdBQUcsRUFBRTtRQUN2QyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztLQUMvQjtJQUVELE9BQU8sY0FBYyxDQUFDO0NBQ3ZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi4vaGVscGVycy9tYXRoLmhlbHBlcnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRGF0YXNldChcbiAgZGF0YTogbnVtYmVyW10sXG4gIG1pblg6IG51bWJlcixcbiAgbWF4WDogbnVtYmVyLFxuICBtaW5ZOiBudW1iZXIsXG4gIG1heFk6IG51bWJlcixcbikge1xuICAvLyBGb3IgdGhlIFggYXhpcywgd2Ugd2FudCB0byBub3JtYWxpemUgaXQgYmFzZWQgb24gaXRzIGluZGV4IGluIHRoZSBhcnJheS5cbiAgLy8gRm9yIHRoZSBZIGF4aXMsIHdlIHdhbnQgdG8gbm9ybWFsaXplIGl0IGJhc2VkIG9uIHRoZSBlbGVtZW50J3MgdmFsdWUuXG4gIC8vXG4gIC8vIFggYXhpcyBpcyBlYXN5OiBqdXN0IGV2ZW5seS1zcGFjZSBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAvLyBGb3IgdGhlIFkgYXhpcywgd2UgZmlyc3QgbmVlZCB0byBmaW5kIHRoZSBtaW4gYW5kIG1heCBvZiBvdXIgYXJyYXksXG4gIC8vIGFuZCB0aGVuIG5vcm1hbGl6ZSB0aG9zZSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLlxuICBjb25zdCBib3VuZGFyaWVzWCA9IHsgbWluOiAwLCBtYXg6IGRhdGEubGVuZ3RoIC0gMSB9O1xuICBjb25zdCBib3VuZGFyaWVzWSA9IHsgbWluOiBNYXRoLm1pbiguLi5kYXRhKSwgbWF4OiBNYXRoLm1heCguLi5kYXRhKSB9O1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWREYXRhID0gZGF0YS5tYXAoKHBvaW50LCBpbmRleCkgPT4gKHtcbiAgICB4OiBub3JtYWxpemUoaW5kZXgsIGJvdW5kYXJpZXNYLm1pbiwgYm91bmRhcmllc1gubWF4LCBtaW5YLCBtYXhYKSxcbiAgICB5OiBub3JtYWxpemUocG9pbnQsIGJvdW5kYXJpZXNZLm1pbiwgYm91bmRhcmllc1kubWF4LCBtaW5ZLCBtYXhZKSxcbiAgfSkpO1xuXG4gIC8vIEFjY29yZGluZyB0byB0aGUgU1ZHIHNwZWMsIHBhdGhzIHdpdGggYSBoZWlnaHQvd2lkdGggb2YgYDBgIGNhbid0IGhhdmVcbiAgLy8gbGluZWFyIGdyYWRpZW50cyBhcHBsaWVkLiBUaGlzIG1lYW5zIHRoYXQgb3VyIGxpbmVzIGFyZSBpbnZpc2libGUgd2hlblxuICAvLyB0aGUgZGF0YXNldCBpcyBmbGF0IChlZy4gWzAsIDAsIDAsIDBdKS5cbiAgLy9cbiAgLy8gVGhlIGhhY2t5IHNvbHV0aW9uIGlzIHRvIGFwcGx5IGEgdmVyeSBzbGlnaHQgb2Zmc2V0IHRvIHRoZSBmaXJzdCBwb2ludCBvZlxuICAvLyB0aGUgZGF0YXNldC4gQXMgdWdseSBhcyBpdCBpcywgaXQncyB0aGUgYmVzdCBzb2x1dGlvbiB3ZSBjYW4gZmluZCAodGhlcmVcbiAgLy8gYXJlIHdheXMgd2l0aGluIHRoZSBTVkcgc3BlYyBvZiBjaGFuZ2luZyBpdCwgYnV0IG5vdCB3aXRob3V0IGNhdXNpbmdcbiAgLy8gYnJlYWtpbmcgY2hhbmdlcykuXG4gIGlmIChib3VuZGFyaWVzWS5taW4gPT09IGJvdW5kYXJpZXNZLm1heCkge1xuICAgIG5vcm1hbGl6ZWREYXRhWzBdLnkgKz0gMC4wMDAxO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWREYXRhO1xufVxuIl19