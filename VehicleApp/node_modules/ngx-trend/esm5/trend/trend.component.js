/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { animate, keyframes, state, style, transition, trigger, } from '@angular/animations';
import { Component, ElementRef, Input, ViewChild, } from '@angular/core';
import { buildLinearPath, buildSmoothPath } from '../helpers/DOM.helpers';
import { normalize } from '../helpers/math.helpers';
import { generateId } from '../helpers/misc.helpers';
import { normalizeDataset } from './trend.helpers';
var TrendComponent = /** @class */ (function () {
    function TrendComponent() {
        this.autoDraw = false;
        this.autoDrawDuration = 2000;
        this.autoDrawEasing = 'ease';
        this.padding = 8;
        this.radius = 10;
        this.stroke = 'black';
        this.strokeLinecap = '';
        this.strokeWidth = 1;
        this.gradient = [];
        this.svgWidth = '100%';
        this.svgHeight = '25%';
        this.animationState = '';
        this.id = generateId();
        this.gradientId = "ngx-trend-vertical-gradient-" + this.id;
    }
    /**
     * @return {?}
     */
    TrendComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // We need at least 2 points to draw a graph.
        if (!this.data || this.data.length < 2) {
            return;
        }
        /** @type {?} */
        var plainValues = this.data.map(function (point) {
            if (typeof point === 'number') {
                return point;
            }
            return point.value;
        });
        /** @type {?} */
        var viewBoxWidth = this.width || 300;
        /** @type {?} */
        var viewBoxHeight = this.height || 75;
        this.svgWidth = this.width || '100%';
        this.svgHeight = this.height || '25%';
        this.viewBox = "0 0 " + viewBoxWidth + " " + viewBoxHeight;
        /** @type {?} */
        var root = location.href.split(location.hash || '#')[0];
        this.pathStroke = (this.gradient && this.gradient.length) ? "url('" + root + "#" + this.gradientId + "')" : undefined;
        this.gradientTrimmed = this.gradient.slice().reverse().map(function (val, idx) {
            return {
                idx: idx,
                stopColor: val,
                offset: normalize(idx, 0, _this.gradient.length - 1 || 1),
            };
        });
        /** @type {?} */
        var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
        // NOTE: Because SVGs are indexed from the top left, but most data is
        // indexed from the bottom left, we're inverting the Y min/max.
        viewBoxHeight - this.padding, this.padding);
        if (this.autoDraw && this.animationState !== 'active') {
            this.animationState = 'inactive';
            setTimeout(function () {
                _this.lineLength = _this.pathEl.nativeElement.getTotalLength();
                _this.animationState = 'active';
            });
        }
        this.d = this.smooth
            ? buildSmoothPath(normalizedValues, this.radius)
            : buildLinearPath(normalizedValues);
    };
    TrendComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-trend',
                    template: "\n  <svg *ngIf=\"data && data.length >= 2\"\n    [attr.width]=\"svgWidth\"\n    [attr.height]=\"svgHeight\"\n    [attr.stroke]=\"stroke\"\n    [attr.stroke-width]=\"strokeWidth\"\n    [attr.stroke-linecap]=\"strokeLinecap\"\n    [attr.viewBox]=\"viewBox\"\n    [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n  >\n    <defs *ngIf=\"gradient && gradient.length\">\n      <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n        <stop\n          *ngFor=\"let g of gradientTrimmed;\"\n          [attr.key]=\"g.idx\"\n          [attr.offset]=\"g.offset\"\n          [attr.stop-color]=\"g.stopColor\"\n        />\n      </linearGradient>\n    </defs>\n    <path fill=\"none\" #pathEl\n      [attr.stroke]=\"pathStroke\" [attr.d]=\"d\"\n      [@pathAnimaiton]=\"{\n        value: animationState,\n        params: {\n          autoDrawDuration: autoDrawDuration,\n          autoDrawEasing: autoDrawEasing,\n          lineLength: lineLength\n        }\n      }\" />\n  </svg>\n  ",
                    animations: [
                        trigger('pathAnimaiton', [
                            state('inactive', style({ display: 'none' })),
                            transition('* => active', [
                                style({ display: 'initial' }),
                                // We do the animation using the dash array/offset trick
                                // https://css-tricks.com/svg-line-animation-works/
                                animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                                    style({
                                        'stroke-dasharray': '{{ lineLength }}px',
                                        'stroke-dashoffset': '{{ lineLength }}px',
                                    }),
                                    style({
                                        'stroke-dasharray': '{{ lineLength }}px',
                                        'stroke-dashoffset': 0,
                                    }),
                                ])),
                                // One unfortunate side-effect of the auto-draw is that the line is
                                // actually 1 big dash, the same length as the line itself. If the
                                // line length changes (eg. radius change, new data), that dash won't
                                // be the same length anymore. We can fix that by removing those
                                // properties once the auto-draw is completed.
                                style({
                                    'stroke-dashoffset': '',
                                    'stroke-dasharray': '',
                                }),
                            ]),
                        ]),
                    ]
                }] }
    ];
    /** @nocollapse */
    TrendComponent.ctorParameters = function () { return []; };
    TrendComponent.propDecorators = {
        data: [{ type: Input }],
        smooth: [{ type: Input }],
        autoDraw: [{ type: Input }],
        autoDrawDuration: [{ type: Input }],
        autoDrawEasing: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        padding: [{ type: Input }],
        radius: [{ type: Input }],
        stroke: [{ type: Input }],
        strokeLinecap: [{ type: Input }],
        strokeWidth: [{ type: Input }],
        gradient: [{ type: Input }],
        preserveAspectRatio: [{ type: Input }],
        pathEl: [{ type: ViewChild, args: ['pathEl',] }]
    };
    return TrendComponent;
}());
export { TrendComponent };
if (false) {
    /** @type {?} */
    TrendComponent.prototype.id;
    /** @type {?} */
    TrendComponent.prototype.data;
    /** @type {?} */
    TrendComponent.prototype.smooth;
    /** @type {?} */
    TrendComponent.prototype.autoDraw;
    /** @type {?} */
    TrendComponent.prototype.autoDrawDuration;
    /** @type {?} */
    TrendComponent.prototype.autoDrawEasing;
    /** @type {?} */
    TrendComponent.prototype.width;
    /** @type {?} */
    TrendComponent.prototype.height;
    /** @type {?} */
    TrendComponent.prototype.padding;
    /** @type {?} */
    TrendComponent.prototype.radius;
    /** @type {?} */
    TrendComponent.prototype.stroke;
    /** @type {?} */
    TrendComponent.prototype.strokeLinecap;
    /** @type {?} */
    TrendComponent.prototype.strokeWidth;
    /** @type {?} */
    TrendComponent.prototype.gradient;
    /** @type {?} */
    TrendComponent.prototype.preserveAspectRatio;
    /** @type {?} */
    TrendComponent.prototype.pathEl;
    /** @type {?} */
    TrendComponent.prototype.gradientTrimmed;
    /** @type {?} */
    TrendComponent.prototype.d;
    /** @type {?} */
    TrendComponent.prototype.svgWidth;
    /** @type {?} */
    TrendComponent.prototype.svgHeight;
    /** @type {?} */
    TrendComponent.prototype.viewBox;
    /** @type {?} */
    TrendComponent.prototype.pathStroke;
    /** @type {?} */
    TrendComponent.prototype.gradientId;
    /** @type {?} */
    TrendComponent.prototype.lineLength;
    /** @type {?} */
    TrendComponent.prototype.animationState;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlbmQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXRyZW5kLyIsInNvdXJjZXMiOlsidHJlbmQvdHJlbmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsT0FBTyxFQUNQLFNBQVMsRUFDVCxLQUFLLEVBQ0wsS0FBSyxFQUNMLFVBQVUsRUFDVixPQUFPLEdBQ1IsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBRUwsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7SUFnR2pEO3dCQXZCb0IsS0FBSztnQ0FDRyxJQUFJOzhCQUNOLE1BQU07dUJBR2IsQ0FBQztzQkFDRixFQUFFO3NCQUNGLE9BQU87NkJBQ0EsRUFBRTsyQkFDSixDQUFDO3dCQUNNLEVBQUU7d0JBS0osTUFBTTt5QkFDTCxLQUFLOzhCQUtqQixFQUFFO1FBR2pCLElBQUksQ0FBQyxFQUFFLEdBQUcsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxpQ0FBK0IsSUFBSSxDQUFDLEVBQUksQ0FBQztLQUM1RDs7OztJQUNELG9DQUFXOzs7SUFBWDtRQUFBLGlCQTREQzs7UUExREMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3RDLE9BQU87U0FDUjs7UUFTRCxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcs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Qjt3Q0FDeEMsbUJBQW1CLEVBQUUsb0JBQW9CO3FDQUMxQyxDQUFDO29DQUNGLEtBQUssQ0FBQzt3Q0FDSixrQkFBa0IsRUFBRSxvQkFBb0I7d0NBQ3hDLG1CQUFtQixFQUFFLENBQUM7cUNBQ3ZCLENBQUM7aUNBQ0gsQ0FBQyxDQUNIOzs7Ozs7Z0NBTUQsS0FBSyxDQUFDO29DQUNKLG1CQUFtQixFQUFFLEVBQUU7b0NBQ3ZCLGtCQUFrQixFQUFFLEVBQUU7aUNBQ3ZCLENBQUM7NkJBQ0gsQ0FBQzt5QkFDSCxDQUFDO3FCQUNIO2lCQUNGOzs7Ozt1QkFHRSxLQUFLO3lCQUNMLEtBQUs7MkJBQ0wsS0FBSzttQ0FDTCxLQUFLO2lDQUNMLEtBQUs7d0JBQ0wsS0FBSzt5QkFDTCxLQUFLOzBCQUNMLEtBQUs7eUJBQ0wsS0FBSzt5QkFDTCxLQUFLO2dDQUNMLEtBQUs7OEJBQ0wsS0FBSzsyQkFDTCxLQUFLO3NDQUNMLEtBQUs7eUJBQ0wsU0FBUyxTQUFDLFFBQVE7O3lCQXhHckI7O1NBd0ZhLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBhbmltYXRlLFxuICBrZXlmcmFtZXMsXG4gIHN0YXRlLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvbixcbiAgdHJpZ2dlcixcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGJ1aWxkTGluZWFyUGF0aCwgYnVpbGRTbW9vdGhQYXRoIH0gZnJvbSAnLi4vaGVscGVycy9ET00uaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuLi9oZWxwZXJzL21hdGguaGVscGVycyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vaGVscGVycy9taXNjLmhlbHBlcnMnO1xuaW1wb3J0IHsgbm9ybWFsaXplRGF0YXNldCB9IGZyb20gJy4vdHJlbmQuaGVscGVycyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LXRyZW5kJyxcbiAgdGVtcGxhdGU6IGBcbiAgPHN2ZyAqbmdJZj1cImRhdGEgJiYgZGF0YS5sZW5ndGggPj0gMlwiXG4gICAgW2F0dHIud2lkdGhdPVwic3ZnV2lkdGhcIlxuICAgIFthdHRyLmhlaWdodF09XCJzdmdIZWlnaHRcIlxuICAgIFthdHRyLnN0cm9rZV09XCJzdHJva2VcIlxuICAgIFthdHRyLnN0cm9rZS13aWR0aF09XCJzdHJva2VXaWR0aFwiXG4gICAgW2F0dHIuc3Ryb2tlLWxpbmVjYXBdPVwic3Ryb2tlTGluZWNhcFwiXG4gICAgW2F0dHIudmlld0JveF09XCJ2aWV3Qm94XCJcbiAgICBbYXR0ci5wcmVzZXJ2ZUFzcGVjdFJhdGlvXT1cInByZXNlcnZlQXNwZWN0UmF0aW9cIlxuICA+XG4gICAgPGRlZnMgKm5nSWY9XCJncmFkaWVudCAmJiBncmFkaWVudC5sZW5ndGhcIj5cbiAgICAgIDxsaW5lYXJHcmFkaWVudCBbYXR0ci5pZF09XCJncmFkaWVudElkXCIgeDE9XCIwJVwiIHkxPVwiMCVcIiB4Mj1cIjAlXCIgeTI9XCIxMDAlXCI+XG4gICAgICAgIDxzdG9wXG4gICAgICAgICAgKm5nRm9yPVwibGV0IGcgb2YgZ3JhZGllbnRUcmltbWVkO1wiXG4gICAgICAgICAgW2F0dHIua2V5XT1cImcuaWR4XCJcbiAgICAgICAgICBbYXR0ci5vZmZzZXRdPVwiZy5vZmZzZXRcIlxuICAgICAgICAgIFthdHRyLnN0b3AtY29sb3JdPVwiZy5zdG9wQ29sb3JcIlxuICAgICAgICAvPlxuICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICA8L2RlZnM+XG4gICAgPHBhdGggZmlsbD1cIm5vbmVcIiAjcGF0aEVsXG4gICAgICBbYXR0ci5zdHJva2VdPVwicGF0aFN0cm9rZVwiIFthdHRyLmRdPVwiZFwiXG4gICAgICBbQHBhdGhBbmltYWl0b25dPVwie1xuICAgICAgICB2YWx1ZTogYW5pbWF0aW9uU3RhdGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGF1dG9EcmF3RHVyYXRpb246IGF1dG9EcmF3RHVyYXRpb24sXG4gICAgICAgICAgYXV0b0RyYXdFYXNpbmc6IGF1dG9EcmF3RWFzaW5nLFxuICAgICAgICAgIGxpbmVMZW5ndGg6IGxpbmVMZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcigncGF0aEFuaW1haXRvbicsIFtcbiAgICAgIHN0YXRlKCdpbmFjdGl2ZScsIHN0eWxlKHsgZGlzcGxheTogJ25vbmUnIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJyogPT4gYWN0aXZlJywgW1xuICAgICAgICBzdHlsZSh7IGRpc3BsYXk6ICdpbml0aWFsJyB9KSxcbiAgICAgICAgLy8gV2UgZG8gdGhlIGFuaW1hdGlvbiB1c2luZyB0aGUgZGFzaCBhcnJheS9vZmZzZXQgdHJpY2tcbiAgICAgICAgLy8gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zdmctbGluZS1hbmltYXRpb24td29ya3MvXG4gICAgICAgIGFuaW1hdGUoJ3t7IGF1dG9EcmF3RHVyYXRpb24gfX1tcyB7eyBhdXRvRHJhd0Vhc2luZyB9fScsXG4gICAgICAgICAga2V5ZnJhbWVzKFtcbiAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3t7IGxpbmVMZW5ndGggfX1weCcsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogMCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgICAgICAvLyBPbmUgdW5mb3J0dW5hdGUgc2lkZS1lZmZlY3Qgb2YgdGhlIGF1dG8tZHJhdyBpcyB0aGF0IHRoZSBsaW5lIGlzXG4gICAgICAgIC8vIGFjdHVhbGx5IDEgYmlnIGRhc2gsIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbGluZSBpdHNlbGYuIElmIHRoZVxuICAgICAgICAvLyBsaW5lIGxlbmd0aCBjaGFuZ2VzIChlZy4gcmFkaXVzIGNoYW5nZSwgbmV3IGRhdGEpLCB0aGF0IGRhc2ggd29uJ3RcbiAgICAgICAgLy8gYmUgdGhlIHNhbWUgbGVuZ3RoIGFueW1vcmUuIFdlIGNhbiBmaXggdGhhdCBieSByZW1vdmluZyB0aG9zZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9uY2UgdGhlIGF1dG8tZHJhdyBpcyBjb21wbGV0ZWQuXG4gICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnJyxcbiAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcnLFxuICAgICAgICB9KSxcbiAgICAgIF0pLFxuICAgIF0pLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmVuZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIGlkOiBudW1iZXI7XG4gIEBJbnB1dCgpIGRhdGE6IChudW1iZXIgfCB7dmFsdWU6IG51bWJlcn0pW107XG4gIEBJbnB1dCgpIHNtb290aDogYm9vbGVhbjtcbiAgQElucHV0KCkgYXV0b0RyYXcgPSBmYWxzZTtcbiAgQElucHV0KCkgYXV0b0RyYXdEdXJhdGlvbiA9IDIwMDA7XG4gIEBJbnB1dCgpIGF1dG9EcmF3RWFzaW5nID0gJ2Vhc2UnO1xuICBASW5wdXQoKSB3aWR0aDogbnVtYmVyO1xuICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlcjtcbiAgQElucHV0KCkgcGFkZGluZyA9IDg7XG4gIEBJbnB1dCgpIHJhZGl1cyA9IDEwO1xuICBASW5wdXQoKSBzdHJva2UgPSAnYmxhY2snO1xuICBASW5wdXQoKSBzdHJva2VMaW5lY2FwID0gJyc7XG4gIEBJbnB1dCgpIHN0cm9rZVdpZHRoID0gMTtcbiAgQElucHV0KCkgZ3JhZGllbnQ6IHN0cmluZ1tdID0gW107XG4gIEBJbnB1dCgpIHByZXNlcnZlQXNwZWN0UmF0aW86IHN0cmluZztcbiAgQFZpZXdDaGlsZCgncGF0aEVsJykgcGF0aEVsOiBFbGVtZW50UmVmO1xuICBncmFkaWVudFRyaW1tZWQ6IGFueVtdO1xuICBkOiBhbnk7XG4gIHN2Z1dpZHRoOiBzdHJpbmcgfCBudW1iZXIgPSAnMTAwJSc7XG4gIHN2Z0hlaWdodDogc3RyaW5nIHwgbnVtYmVyID0gJzI1JSc7XG4gIHZpZXdCb3g6IHN0cmluZztcbiAgcGF0aFN0cm9rZTogYW55O1xuICBncmFkaWVudElkOiBzdHJpbmc7XG4gIGxpbmVMZW5ndGg6IG51bWJlcjtcbiAgYW5pbWF0aW9uU3RhdGUgPSAnJztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuZ3JhZGllbnRJZCA9IGBuZ3gtdHJlbmQtdmVydGljYWwtZ3JhZGllbnQtJHt0aGlzLmlkfWA7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cyB0byBkcmF3IGEgZ3JhcGguXG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBgZGF0YWAgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBudW1iZXJzOlxuICAgIC8vIFsxLCAyLCAzXVxuICAgIC8vIG9yLCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSB2YWx1ZTpcbiAgICAvLyBbeyB2YWx1ZTogMSB9LCB7IHZhbHVlOiAyIH0sIHsgdmFsdWU6IDMgfV1cbiAgICAvL1xuICAgIC8vIEZvciBub3csIHdlJ3JlIGp1c3QgZ29pbmcgdG8gY29udmVydCB0aGUgc2Vjb25kIGZvcm0gdG8gdGhlIGZpcnN0LlxuICAgIC8vIExhdGVyIG9uLCBpZi93aGVuIHdlIHN1cHBvcnQgdG9vbHRpcHMsIHdlIG1heSBhZGp1c3QuXG4gICAgY29uc3QgcGxhaW5WYWx1ZXMgPSB0aGlzLmRhdGEubWFwKChwb2ludCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50LnZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT3VyIHZpZXdib3ggbmVlZHMgdG8gYmUgaW4gYWJzb2x1dGUgdW5pdHMsIHNvIHdlJ2xsIGRlZmF1bHQgdG8gMzAweDc1XG4gICAgLy8gT3VyIFNWRyBjYW4gYmUgYSAlLCB0aG91Z2g7IHRoaXMgaXMgd2hhdCBtYWtlcyBpdCBzY2FsYWJsZS5cbiAgICAvLyBCeSBkZWZhdWx0aW5nIHRvIHBlcmNlbnRhZ2VzLCB0aGUgU1ZHIHdpbGwgZ3JvdyB0byBmaWxsIGl0cyBwYXJlbnRcbiAgICAvLyBjb250YWluZXIsIHByZXNlcnZpbmcgYSAxLzQgYXNwZWN0IHJhdGlvLlxuICAgIGNvbnN0IHZpZXdCb3hXaWR0aCA9IHRoaXMud2lkdGggfHwgMzAwO1xuICAgIGNvbnN0IHZpZXdCb3hIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCA3NTtcbiAgICB0aGlzLnN2Z1dpZHRoID0gdGhpcy53aWR0aCB8fCAnMTAwJSc7XG4gICAgdGhpcy5zdmdIZWlnaHQgPSB0aGlzLmhlaWdodCB8fCAnMjUlJztcbiAgICB0aGlzLnZpZXdCb3ggPSBgMCAwICR7dmlld0JveFdpZHRofSAke3ZpZXdCb3hIZWlnaHR9YDtcbiAgICBjb25zdCByb290ID0gbG9jYXRpb24uaHJlZi5zcGxpdChsb2NhdGlvbi5oYXNoIHx8ICcjJylbMF07XG4gICAgdGhpcy5wYXRoU3Ryb2tlID0gKHRoaXMuZ3JhZGllbnQgJiYgdGhpcy5ncmFkaWVudC5sZW5ndGgpID8gYHVybCgnJHtyb290fSMke3RoaXMuZ3JhZGllbnRJZH0nKWAgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmdyYWRpZW50VHJpbW1lZCA9IHRoaXMuZ3JhZGllbnQuc2xpY2UoKS5yZXZlcnNlKCkubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWR4LFxuICAgICAgICBzdG9wQ29sb3I6IHZhbCxcbiAgICAgICAgb2Zmc2V0OiBub3JtYWxpemUoaWR4LCAwLCB0aGlzLmdyYWRpZW50Lmxlbmd0aCAtIDEgfHwgMSksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlcyA9IG5vcm1hbGl6ZURhdGFzZXQocGxhaW5WYWx1ZXMsXG4gICAgICB0aGlzLnBhZGRpbmcsXG4gICAgICB2aWV3Qm94V2lkdGggLSB0aGlzLnBhZGRpbmcsXG4gICAgICAvLyBOT1RFOiBCZWNhdXNlIFNWR3MgYXJlIGluZGV4ZWQgZnJvbSB0aGUgdG9wIGxlZnQsIGJ1dCBtb3N0IGRhdGEgaXNcbiAgICAgIC8vIGluZGV4ZWQgZnJvbSB0aGUgYm90dG9tIGxlZnQsIHdlJ3JlIGludmVydGluZyB0aGUgWSBtaW4vbWF4LlxuICAgICAgdmlld0JveEhlaWdodCAtIHRoaXMucGFkZGluZyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuYXV0b0RyYXcgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5hY3RpdmUnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IHRoaXMucGF0aEVsLm5hdGl2ZUVsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kID0gdGhpcy5zbW9vdGhcbiAgICAgID8gYnVpbGRTbW9vdGhQYXRoKG5vcm1hbGl6ZWRWYWx1ZXMsIHRoaXMucmFkaXVzKVxuICAgICAgOiBidWlsZExpbmVhclBhdGgobm9ybWFsaXplZFZhbHVlcyk7XG4gIH1cbn1cbiJdfQ==