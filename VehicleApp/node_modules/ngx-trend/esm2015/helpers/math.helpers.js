/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/* eslint-disable no-restricted-properties */
/**
 * normalize
 * This lets us translate a value from one scale to another.
 *
 * @param {?} value - Our initial value to translate
 * @param {?} min - the current minimum value possible
 * @param {?} max - the current maximum value possible
 * @param {?=} scaleMin - the min value of the scale we're translating to
 * @param {?=} scaleMax - the max value of the scale we're translating to
 *
 * @return {?} the value on its new scale
 */
export function normalize(value, min, max, scaleMin = 0, scaleMax = 1) {
    // If the `min` and `max` are the same value, it means our dataset is flat.
    // For now, let's assume that flat data should be aligned to the bottom.
    if (min === max) {
        return scaleMin;
    }
    return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
}
/**
 * @record
 */
export function Point() { }
/** @type {?} */
Point.prototype.x;
/** @type {?} */
Point.prototype.y;
/**
 * moveTo
 * the coordinate that lies at a midpoint between 2 lines, based on the radius
 *
 * @param {?} to - Our initial point
 * @param {?} from - Our final point
 * @param {?} radius - The distance away from the final point
 *
 * @return {?} an object holding the x/y coordinates of the midpoint.
 */
export function moveTo(to, from, radius) {
    /** @type {?} */
    const length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
    /** @type {?} */
    const unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
    return {
        x: from.x + unitVector.x * radius,
        y: from.y + unitVector.y * radius,
    };
}
/** *
 * getDistanceBetween
 * Simple formula derived from pythagoras to calculate the distance between
 * 2 points on a plane.
 *
 * \@param p1 - Our initial point
 * \@param p1.x - The x value of our initial point
 * \@param p1.y - The y value of our initial point
 * \@param p2 - Our final point
 * \@param p2.x - The x value of our final point
 * \@param p2.y - The y value of our final point
 *
 * \@return the distance between the points.
  @type {?} */
export const getDistanceBetween = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
/** *
 * checkForCollinearPoints
 * Figure out if the midpoint fits perfectly on a line between the two others.
 *
 * \@param p1 - Our initial point
 * \@param p1.x - The x value of our initial point
 * \@param p1.y - The y value of our initial point
 * \@param p2 - Our mid-point
 * \@param p2.x - The x value of our mid-point
 * \@param p2.y - The y value of our mid-point
 * \@param p3 - Our final point
 * \@param p3.x - The x value of our final point
 * \@param p3.y - The y value of our final point
 * \@return whether or not p2 sits on the line between p1 and p3.
  @type {?} */
export const checkForCollinearPoints = (p1, p2, p3) => (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aC5oZWxwZXJzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXRyZW5kLyIsInNvdXJjZXMiOlsiaGVscGVycy9tYXRoLmhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhQSxNQUFNLG9CQUNKLEtBQWEsRUFDYixHQUFXLEVBQ1gsR0FBVyxFQUNYLFFBQVEsR0FBRyxDQUFDLEVBQ1osUUFBUSxHQUFHLENBQUM7OztJQUlaLElBQUksR0FBRyxLQUFLLEdBQUcsRUFBRTtRQUNmLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO0lBRUQsT0FBTyxRQUFRLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7Q0FDdkU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkQsTUFBTSxpQkFBaUIsRUFBUyxFQUFFLElBQVcsRUFBRSxNQUFjOztJQUMzRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFDaEcsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFFaEYsT0FBTztRQUNMLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsTUFBTTtRQUNqQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLE1BQU07S0FDbEMsQ0FBQztDQUNIOzs7Ozs7Ozs7Ozs7Ozs7QUFlRCxhQUFhLGtCQUFrQixHQUFHLENBQUMsRUFBUyxFQUFFLEVBQVMsRUFBRSxFQUFFLENBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCakUsYUFBYSx1QkFBdUIsR0FBRyxDQUFDLEVBQVMsRUFBRSxFQUFTLEVBQUUsRUFBUyxFQUFFLEVBQUUsQ0FDekUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG4vKiogbm9ybWFsaXplXG4gKiBUaGlzIGxldHMgdXMgdHJhbnNsYXRlIGEgdmFsdWUgZnJvbSBvbmUgc2NhbGUgdG8gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBPdXIgaW5pdGlhbCB2YWx1ZSB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSBtaW4gLSB0aGUgY3VycmVudCBtaW5pbXVtIHZhbHVlIHBvc3NpYmxlXG4gKiBAcGFyYW0gbWF4IC0gdGhlIGN1cnJlbnQgbWF4aW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIHNjYWxlTWluIC0gdGhlIG1pbiB2YWx1ZSBvZiB0aGUgc2NhbGUgd2UncmUgdHJhbnNsYXRpbmcgdG9cbiAqIEBwYXJhbSBzY2FsZU1heCAtIHRoZSBtYXggdmFsdWUgb2YgdGhlIHNjYWxlIHdlJ3JlIHRyYW5zbGF0aW5nIHRvXG4gKlxuICogQHJldHVybnMgdGhlIHZhbHVlIG9uIGl0cyBuZXcgc2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShcbiAgdmFsdWU6IG51bWJlcixcbiAgbWluOiBudW1iZXIsXG4gIG1heDogbnVtYmVyLFxuICBzY2FsZU1pbiA9IDAsXG4gIHNjYWxlTWF4ID0gMSxcbikge1xuICAvLyBJZiB0aGUgYG1pbmAgYW5kIGBtYXhgIGFyZSB0aGUgc2FtZSB2YWx1ZSwgaXQgbWVhbnMgb3VyIGRhdGFzZXQgaXMgZmxhdC5cbiAgLy8gRm9yIG5vdywgbGV0J3MgYXNzdW1lIHRoYXQgZmxhdCBkYXRhIHNob3VsZCBiZSBhbGlnbmVkIHRvIHRoZSBib3R0b20uXG4gIGlmIChtaW4gPT09IG1heCkge1xuICAgIHJldHVybiBzY2FsZU1pbjtcbiAgfVxuXG4gIHJldHVybiBzY2FsZU1pbiArICh2YWx1ZSAtIG1pbikgKiAoc2NhbGVNYXggLSBzY2FsZU1pbikgLyAobWF4IC0gbWluKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufVxuXG4vKiogbW92ZVRvXG4gKiB0aGUgY29vcmRpbmF0ZSB0aGF0IGxpZXMgYXQgYSBtaWRwb2ludCBiZXR3ZWVuIDIgbGluZXMsIGJhc2VkIG9uIHRoZSByYWRpdXNcbiAqXG4gKiBAcGFyYW0gdG8gLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHRvLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHRvLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIGZyb20gLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSByYWRpdXMgLSBUaGUgZGlzdGFuY2UgYXdheSBmcm9tIHRoZSBmaW5hbCBwb2ludFxuICpcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBob2xkaW5nIHRoZSB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIG1pZHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW92ZVRvKHRvOiBQb2ludCwgZnJvbTogUG9pbnQsIHJhZGl1czogbnVtYmVyKTogUG9pbnQge1xuICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoKHRvLnggLSBmcm9tLngpICogKHRvLnggLSBmcm9tLngpICsgKHRvLnkgLSBmcm9tLnkpICogKHRvLnkgLSBmcm9tLnkpKTtcbiAgY29uc3QgdW5pdFZlY3RvciA9IHsgeDogKHRvLnggLSBmcm9tLngpIC8gbGVuZ3RoLCB5OiAodG8ueSAtIGZyb20ueSkgLyBsZW5ndGggfTtcblxuICByZXR1cm4ge1xuICAgIHg6IGZyb20ueCArIHVuaXRWZWN0b3IueCAqIHJhZGl1cyxcbiAgICB5OiBmcm9tLnkgKyB1bml0VmVjdG9yLnkgKiByYWRpdXMsXG4gIH07XG59XG5cbi8qKiBnZXREaXN0YW5jZUJldHdlZW5cbiAqIFNpbXBsZSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBweXRoYWdvcmFzIHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxuICogMiBwb2ludHMgb24gYSBwbGFuZS5cbiAqXG4gKiBAcGFyYW0gcDEgLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAyIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDIueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqXG4gKiBAcmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0RGlzdGFuY2VCZXR3ZWVuID0gKHAxOiBQb2ludCwgcDI6IFBvaW50KSA9PlxuICBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcblxuLyoqIGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzXG4gKiBGaWd1cmUgb3V0IGlmIHRoZSBtaWRwb2ludCBmaXRzIHBlcmZlY3RseSBvbiBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIG90aGVycy5cbiAqXG4gKiBAcGFyYW0gcDEgLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAyIC0gT3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAyLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDIueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMyAtIE91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAzLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMy55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG5cbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHAyIHNpdHMgb24gdGhlIGxpbmUgYmV0d2VlbiBwMSBhbmQgcDMuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0ZvckNvbGxpbmVhclBvaW50cyA9IChwMTogUG9pbnQsIHAyOiBQb2ludCwgcDM6IFBvaW50KSA9PlxuICAocDEueSAtIHAyLnkpICogKHAxLnggLSBwMy54KSA9PT0gKHAxLnkgLSBwMy55KSAqIChwMS54IC0gcDIueCk7XG4iXX0=