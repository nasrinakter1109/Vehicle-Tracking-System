import { __spread, __read } from 'tslib';
import { animate, keyframes, state, style, transition, trigger } from '@angular/animations';
import { Component, Input, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/* eslint-disable no-restricted-properties */
/**
 * normalize
 * This lets us translate a value from one scale to another.
 *
 * @param {?} value - Our initial value to translate
 * @param {?} min - the current minimum value possible
 * @param {?} max - the current maximum value possible
 * @param {?=} scaleMin - the min value of the scale we're translating to
 * @param {?=} scaleMax - the max value of the scale we're translating to
 *
 * @return {?} the value on its new scale
 */
function normalize(value, min, max, scaleMin, scaleMax) {
    if (scaleMin === void 0) { scaleMin = 0; }
    if (scaleMax === void 0) { scaleMax = 1; }
    // If the `min` and `max` are the same value, it means our dataset is flat.
    // For now, let's assume that flat data should be aligned to the bottom.
    if (min === max) {
        return scaleMin;
    }
    return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);
}
/**
 * moveTo
 * the coordinate that lies at a midpoint between 2 lines, based on the radius
 *
 * @param {?} to - Our initial point
 * @param {?} from - Our final point
 * @param {?} radius - The distance away from the final point
 *
 * @return {?} an object holding the x/y coordinates of the midpoint.
 */
function moveTo(to, from, radius) {
    /** @type {?} */
    var length = Math.sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
    /** @type {?} */
    var unitVector = { x: (to.x - from.x) / length, y: (to.y - from.y) / length };
    return {
        x: from.x + unitVector.x * radius,
        y: from.y + unitVector.y * radius,
    };
}
/** *
 * getDistanceBetween
 * Simple formula derived from pythagoras to calculate the distance between
 * 2 points on a plane.
 *
 * \@param p1 - Our initial point
 * \@param p1.x - The x value of our initial point
 * \@param p1.y - The y value of our initial point
 * \@param p2 - Our final point
 * \@param p2.x - The x value of our final point
 * \@param p2.y - The y value of our final point
 *
 * \@return the distance between the points.
  @type {?} */
var getDistanceBetween = function (p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
};
/** *
 * checkForCollinearPoints
 * Figure out if the midpoint fits perfectly on a line between the two others.
 *
 * \@param p1 - Our initial point
 * \@param p1.x - The x value of our initial point
 * \@param p1.y - The y value of our initial point
 * \@param p2 - Our mid-point
 * \@param p2.x - The x value of our mid-point
 * \@param p2.y - The y value of our mid-point
 * \@param p3 - Our final point
 * \@param p3.x - The x value of our final point
 * \@param p3.y - The y value of our final point
 * \@return whether or not p2 sits on the line between p1 and p3.
  @type {?} */
var checkForCollinearPoints = function (p1, p2, p3) {
    return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var buildLinearPath = function (data) {
    return data.reduce(function (path, point, index) {
        /** @type {?} */
        var isFirstInstruction = index === 0;
        /** @type {?} */
        var instruction = isFirstInstruction ? 'M' : 'L';
        return "" + path + instruction + " " + point.x + "," + point.y + "\n";
    }, '');
};
/**
 * @param {?} data
 * @param {?} radius
 * @return {?}
 */
function buildSmoothPath(data, radius) {
    var _a = __read(data), firstPoint = _a[0], otherPoints = _a.slice(1);
    return otherPoints.reduce(function (path, point, index) {
        /** @type {?} */
        var next = otherPoints[index + 1];
        /** @type {?} */
        var prev = otherPoints[index - 1] || firstPoint;
        /** @type {?} */
        var isCollinear = next && checkForCollinearPoints(prev, point, next);
        if (!next || isCollinear) {
            // The very last line in the sequence can just be a regular line.
            return path + "\nL " + point.x + "," + point.y;
        }
        /** @type {?} */
        var distanceFromPrev = getDistanceBetween(prev, point);
        /** @type {?} */
        var distanceFromNext = getDistanceBetween(next, point);
        /** @type {?} */
        var threshold = Math.min(distanceFromPrev, distanceFromNext);
        /** @type {?} */
        var isTooCloseForRadius = threshold / 2 < radius;
        /** @type {?} */
        var radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
        /** @type {?} */
        var before = moveTo(prev, point, radiusForPoint);
        /** @type {?} */
        var after = moveTo(next, point, radiusForPoint);
        return [
            path,
            "L " + before.x + "," + before.y,
            "S " + point.x + "," + point.y + " " + after.x + "," + after.y,
        ].join('\n');
    }, "M " + firstPoint.x + "," + firstPoint.y);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var generateId = function () { return Math.round(Math.random() * Math.pow(10, 16)); };

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} data
 * @param {?} minX
 * @param {?} maxX
 * @param {?} minY
 * @param {?} maxY
 * @return {?}
 */
function normalizeDataset(data, minX, maxX, minY, maxY) {
    /** @type {?} */
    var boundariesX = { min: 0, max: data.length - 1 };
    /** @type {?} */
    var boundariesY = { min: Math.min.apply(Math, __spread(data)), max: Math.max.apply(Math, __spread(data)) };
    /** @type {?} */
    var normalizedData = data.map(function (point, index) { return ({
        x: normalize(index, boundariesX.min, boundariesX.max, minX, maxX),
        y: normalize(point, boundariesY.min, boundariesY.max, minY, maxY),
    }); });
    // According to the SVG spec, paths with a height/width of `0` can't have
    // linear gradients applied. This means that our lines are invisible when
    // the dataset is flat (eg. [0, 0, 0, 0]).
    //
    // The hacky solution is to apply a very slight offset to the first point of
    // the dataset. As ugly as it is, it's the best solution we can find (there
    // are ways within the SVG spec of changing it, but not without causing
    // breaking changes).
    if (boundariesY.min === boundariesY.max) {
        normalizedData[0].y += 0.0001;
    }
    return normalizedData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var TrendComponent = /** @class */ (function () {
    function TrendComponent() {
        this.autoDraw = false;
        this.autoDrawDuration = 2000;
        this.autoDrawEasing = 'ease';
        this.padding = 8;
        this.radius = 10;
        this.stroke = 'black';
        this.strokeLinecap = '';
        this.strokeWidth = 1;
        this.gradient = [];
        this.svgWidth = '100%';
        this.svgHeight = '25%';
        this.animationState = '';
        this.id = generateId();
        this.gradientId = "ngx-trend-vertical-gradient-" + this.id;
    }
    /**
     * @return {?}
     */
    TrendComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // We need at least 2 points to draw a graph.
        if (!this.data || this.data.length < 2) {
            return;
        }
        /** @type {?} */
        var plainValues = this.data.map(function (point) {
            if (typeof point === 'number') {
                return point;
            }
            return point.value;
        });
        /** @type {?} */
        var viewBoxWidth = this.width || 300;
        /** @type {?} */
        var viewBoxHeight = this.height || 75;
        this.svgWidth = this.width || '100%';
        this.svgHeight = this.height || '25%';
        this.viewBox = "0 0 " + viewBoxWidth + " " + viewBoxHeight;
        /** @type {?} */
        var root = location.href.split(location.hash || '#')[0];
        this.pathStroke = (this.gradient && this.gradient.length) ? "url('" + root + "#" + this.gradientId + "')" : undefined;
        this.gradientTrimmed = this.gradient.slice().reverse().map(function (val, idx) {
            return {
                idx: idx,
                stopColor: val,
                offset: normalize(idx, 0, _this.gradient.length - 1 || 1),
            };
        });
        /** @type {?} */
        var normalizedValues = normalizeDataset(plainValues, this.padding, viewBoxWidth - this.padding, 
        // NOTE: Because SVGs are indexed from the top left, but most data is
        // indexed from the bottom left, we're inverting the Y min/max.
        viewBoxHeight - this.padding, this.padding);
        if (this.autoDraw && this.animationState !== 'active') {
            this.animationState = 'inactive';
            setTimeout(function () {
                _this.lineLength = _this.pathEl.nativeElement.getTotalLength();
                _this.animationState = 'active';
            });
        }
        this.d = this.smooth
            ? buildSmoothPath(normalizedValues, this.radius)
            : buildLinearPath(normalizedValues);
    };
    TrendComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-trend',
                    template: "\n  <svg *ngIf=\"data && data.length >= 2\"\n    [attr.width]=\"svgWidth\"\n    [attr.height]=\"svgHeight\"\n    [attr.stroke]=\"stroke\"\n    [attr.stroke-width]=\"strokeWidth\"\n    [attr.stroke-linecap]=\"strokeLinecap\"\n    [attr.viewBox]=\"viewBox\"\n    [attr.preserveAspectRatio]=\"preserveAspectRatio\"\n  >\n    <defs *ngIf=\"gradient && gradient.length\">\n      <linearGradient [attr.id]=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n        <stop\n          *ngFor=\"let g of gradientTrimmed;\"\n          [attr.key]=\"g.idx\"\n          [attr.offset]=\"g.offset\"\n          [attr.stop-color]=\"g.stopColor\"\n        />\n      </linearGradient>\n    </defs>\n    <path fill=\"none\" #pathEl\n      [attr.stroke]=\"pathStroke\" [attr.d]=\"d\"\n      [@pathAnimaiton]=\"{\n        value: animationState,\n        params: {\n          autoDrawDuration: autoDrawDuration,\n          autoDrawEasing: autoDrawEasing,\n          lineLength: lineLength\n        }\n      }\" />\n  </svg>\n  ",
                    animations: [
                        trigger('pathAnimaiton', [
                            state('inactive', style({ display: 'none' })),
                            transition('* => active', [
                                style({ display: 'initial' }),
                                // We do the animation using the dash array/offset trick
                                // https://css-tricks.com/svg-line-animation-works/
                                animate('{{ autoDrawDuration }}ms {{ autoDrawEasing }}', keyframes([
                                    style({
                                        'stroke-dasharray': '{{ lineLength }}px',
                                        'stroke-dashoffset': '{{ lineLength }}px',
                                    }),
                                    style({
                                        'stroke-dasharray': '{{ lineLength }}px',
                                        'stroke-dashoffset': 0,
                                    }),
                                ])),
                                // One unfortunate side-effect of the auto-draw is that the line is
                                // actually 1 big dash, the same length as the line itself. If the
                                // line length changes (eg. radius change, new data), that dash won't
                                // be the same length anymore. We can fix that by removing those
                                // properties once the auto-draw is completed.
                                style({
                                    'stroke-dashoffset': '',
                                    'stroke-dasharray': '',
                                }),
                            ]),
                        ]),
                    ]
                }] }
    ];
    /** @nocollapse */
    TrendComponent.ctorParameters = function () { return []; };
    TrendComponent.propDecorators = {
        data: [{ type: Input }],
        smooth: [{ type: Input }],
        autoDraw: [{ type: Input }],
        autoDrawDuration: [{ type: Input }],
        autoDrawEasing: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        padding: [{ type: Input }],
        radius: [{ type: Input }],
        stroke: [{ type: Input }],
        strokeLinecap: [{ type: Input }],
        strokeWidth: [{ type: Input }],
        gradient: [{ type: Input }],
        preserveAspectRatio: [{ type: Input }],
        pathEl: [{ type: ViewChild, args: ['pathEl',] }]
    };
    return TrendComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var TrendModule = /** @class */ (function () {
    function TrendModule() {
    }
    TrendModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [TrendComponent],
                    declarations: [TrendComponent],
                },] }
    ];
    return TrendModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { TrendComponent, TrendModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXRyZW5kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtdHJlbmQvaGVscGVycy9tYXRoLmhlbHBlcnMudHMiLCJuZzovL25neC10cmVuZC9oZWxwZXJzL0RPTS5oZWxwZXJzLnRzIiwibmc6Ly9uZ3gtdHJlbmQvaGVscGVycy9taXNjLmhlbHBlcnMudHMiLCJuZzovL25neC10cmVuZC90cmVuZC90cmVuZC5oZWxwZXJzLnRzIiwibmc6Ly9uZ3gtdHJlbmQvdHJlbmQvdHJlbmQuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtdHJlbmQvdHJlbmQvdHJlbmQubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG4vKiogbm9ybWFsaXplXG4gKiBUaGlzIGxldHMgdXMgdHJhbnNsYXRlIGEgdmFsdWUgZnJvbSBvbmUgc2NhbGUgdG8gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBPdXIgaW5pdGlhbCB2YWx1ZSB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSBtaW4gLSB0aGUgY3VycmVudCBtaW5pbXVtIHZhbHVlIHBvc3NpYmxlXG4gKiBAcGFyYW0gbWF4IC0gdGhlIGN1cnJlbnQgbWF4aW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIHNjYWxlTWluIC0gdGhlIG1pbiB2YWx1ZSBvZiB0aGUgc2NhbGUgd2UncmUgdHJhbnNsYXRpbmcgdG9cbiAqIEBwYXJhbSBzY2FsZU1heCAtIHRoZSBtYXggdmFsdWUgb2YgdGhlIHNjYWxlIHdlJ3JlIHRyYW5zbGF0aW5nIHRvXG4gKlxuICogQHJldHVybnMgdGhlIHZhbHVlIG9uIGl0cyBuZXcgc2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShcbiAgdmFsdWU6IG51bWJlcixcbiAgbWluOiBudW1iZXIsXG4gIG1heDogbnVtYmVyLFxuICBzY2FsZU1pbiA9IDAsXG4gIHNjYWxlTWF4ID0gMSxcbikge1xuICAvLyBJZiB0aGUgYG1pbmAgYW5kIGBtYXhgIGFyZSB0aGUgc2FtZSB2YWx1ZSwgaXQgbWVhbnMgb3VyIGRhdGFzZXQgaXMgZmxhdC5cbiAgLy8gRm9yIG5vdywgbGV0J3MgYXNzdW1lIHRoYXQgZmxhdCBkYXRhIHNob3VsZCBiZSBhbGlnbmVkIHRvIHRoZSBib3R0b20uXG4gIGlmIChtaW4gPT09IG1heCkge1xuICAgIHJldHVybiBzY2FsZU1pbjtcbiAgfVxuXG4gIHJldHVybiBzY2FsZU1pbiArICh2YWx1ZSAtIG1pbikgKiAoc2NhbGVNYXggLSBzY2FsZU1pbikgLyAobWF4IC0gbWluKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufVxuXG4vKiogbW92ZVRvXG4gKiB0aGUgY29vcmRpbmF0ZSB0aGF0IGxpZXMgYXQgYSBtaWRwb2ludCBiZXR3ZWVuIDIgbGluZXMsIGJhc2VkIG9uIHRoZSByYWRpdXNcbiAqXG4gKiBAcGFyYW0gdG8gLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHRvLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHRvLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIGZyb20gLSBPdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBmcm9tLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSByYWRpdXMgLSBUaGUgZGlzdGFuY2UgYXdheSBmcm9tIHRoZSBmaW5hbCBwb2ludFxuICpcbiAqIEByZXR1cm5zIGFuIG9iamVjdCBob2xkaW5nIHRoZSB4L3kgY29vcmRpbmF0ZXMgb2YgdGhlIG1pZHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW92ZVRvKHRvOiBQb2ludCwgZnJvbTogUG9pbnQsIHJhZGl1czogbnVtYmVyKTogUG9pbnQge1xuICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoKHRvLnggLSBmcm9tLngpICogKHRvLnggLSBmcm9tLngpICsgKHRvLnkgLSBmcm9tLnkpICogKHRvLnkgLSBmcm9tLnkpKTtcbiAgY29uc3QgdW5pdFZlY3RvciA9IHsgeDogKHRvLnggLSBmcm9tLngpIC8gbGVuZ3RoLCB5OiAodG8ueSAtIGZyb20ueSkgLyBsZW5ndGggfTtcblxuICByZXR1cm4ge1xuICAgIHg6IGZyb20ueCArIHVuaXRWZWN0b3IueCAqIHJhZGl1cyxcbiAgICB5OiBmcm9tLnkgKyB1bml0VmVjdG9yLnkgKiByYWRpdXMsXG4gIH07XG59XG5cbi8qKiBnZXREaXN0YW5jZUJldHdlZW5cbiAqIFNpbXBsZSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBweXRoYWdvcmFzIHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxuICogMiBwb2ludHMgb24gYSBwbGFuZS5cbiAqXG4gKiBAcGFyYW0gcDEgLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAyIC0gT3VyIGZpbmFsIHBvaW50XG4gKiBAcGFyYW0gcDIueCAtIFRoZSB4IHZhbHVlIG9mIG91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAyLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqXG4gKiBAcmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0RGlzdGFuY2VCZXR3ZWVuID0gKHAxOiBQb2ludCwgcDI6IFBvaW50KSA9PlxuICBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcblxuLyoqIGNoZWNrRm9yQ29sbGluZWFyUG9pbnRzXG4gKiBGaWd1cmUgb3V0IGlmIHRoZSBtaWRwb2ludCBmaXRzIHBlcmZlY3RseSBvbiBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIG90aGVycy5cbiAqXG4gKiBAcGFyYW0gcDEgLSBPdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAxLnkgLSBUaGUgeSB2YWx1ZSBvZiBvdXIgaW5pdGlhbCBwb2ludFxuICogQHBhcmFtIHAyIC0gT3VyIG1pZC1wb2ludFxuICogQHBhcmFtIHAyLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgbWlkLXBvaW50XG4gKiBAcGFyYW0gcDIueSAtIFRoZSB5IHZhbHVlIG9mIG91ciBtaWQtcG9pbnRcbiAqIEBwYXJhbSBwMyAtIE91ciBmaW5hbCBwb2ludFxuICogQHBhcmFtIHAzLnggLSBUaGUgeCB2YWx1ZSBvZiBvdXIgZmluYWwgcG9pbnRcbiAqIEBwYXJhbSBwMy55IC0gVGhlIHkgdmFsdWUgb2Ygb3VyIGZpbmFsIHBvaW50XG5cbiAqIEByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHAyIHNpdHMgb24gdGhlIGxpbmUgYmV0d2VlbiBwMSBhbmQgcDMuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0ZvckNvbGxpbmVhclBvaW50cyA9IChwMTogUG9pbnQsIHAyOiBQb2ludCwgcDM6IFBvaW50KSA9PlxuICAocDEueSAtIHAyLnkpICogKHAxLnggLSBwMy54KSA9PT0gKHAxLnkgLSBwMy55KSAqIChwMS54IC0gcDIueCk7XG4iLCJpbXBvcnQge1xuICBjaGVja0ZvckNvbGxpbmVhclBvaW50cyxcbiAgZ2V0RGlzdGFuY2VCZXR3ZWVuLFxuICBtb3ZlVG8sXG4gIFBvaW50LFxufSBmcm9tICcuL21hdGguaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBidWlsZExpbmVhclBhdGggPSAoZGF0YTogUG9pbnRbXSkgPT5cbiAgZGF0YS5yZWR1Y2UoKHBhdGgsIHBvaW50LCBpbmRleCkgPT4ge1xuICAgIC8vIFRoZSB2ZXJ5IGZpcnN0IGluc3RydWN0aW9uIG5lZWRzIHRvIGJlIGEgXCJtb3ZlXCIuXG4gICAgLy8gVGhlIHJlc3Qgd2lsbCBiZSBhIFwibGluZVwiLlxuICAgIGNvbnN0IGlzRmlyc3RJbnN0cnVjdGlvbiA9IGluZGV4ID09PSAwO1xuICAgIGNvbnN0IGluc3RydWN0aW9uID0gaXNGaXJzdEluc3RydWN0aW9uID8gJ00nIDogJ0wnO1xuXG4gICAgcmV0dXJuIGAke3BhdGh9JHtpbnN0cnVjdGlvbn0gJHtwb2ludC54fSwke3BvaW50Lnl9XFxuYDtcbiAgfSwgJycpO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTbW9vdGhQYXRoKGRhdGE6IFBvaW50W10sIHJhZGl1czogbnVtYmVyKSB7XG4gIGNvbnN0IFtmaXJzdFBvaW50LCAuLi5vdGhlclBvaW50c10gPSBkYXRhO1xuXG4gIHJldHVybiBvdGhlclBvaW50cy5yZWR1Y2UoKHBhdGgsIHBvaW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSBvdGhlclBvaW50c1tpbmRleCArIDFdO1xuICAgIGNvbnN0IHByZXYgPSBvdGhlclBvaW50c1tpbmRleCAtIDFdIHx8IGZpcnN0UG9pbnQ7XG5cbiAgICBjb25zdCBpc0NvbGxpbmVhciA9IG5leHQgJiYgY2hlY2tGb3JDb2xsaW5lYXJQb2ludHMocHJldiwgcG9pbnQsIG5leHQpO1xuXG4gICAgaWYgKCFuZXh0IHx8IGlzQ29sbGluZWFyKSB7XG4gICAgICAvLyBUaGUgdmVyeSBsYXN0IGxpbmUgaW4gdGhlIHNlcXVlbmNlIGNhbiBqdXN0IGJlIGEgcmVndWxhciBsaW5lLlxuICAgICAgcmV0dXJuIGAke3BhdGh9XFxuTCAke3BvaW50Lnh9LCR7cG9pbnQueX1gO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlRnJvbVByZXYgPSBnZXREaXN0YW5jZUJldHdlZW4ocHJldiwgcG9pbnQpO1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbU5leHQgPSBnZXREaXN0YW5jZUJldHdlZW4obmV4dCwgcG9pbnQpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IE1hdGgubWluKGRpc3RhbmNlRnJvbVByZXYsIGRpc3RhbmNlRnJvbU5leHQpO1xuXG4gICAgY29uc3QgaXNUb29DbG9zZUZvclJhZGl1cyA9IHRocmVzaG9sZCAvIDIgPCByYWRpdXM7XG5cbiAgICBjb25zdCByYWRpdXNGb3JQb2ludCA9IGlzVG9vQ2xvc2VGb3JSYWRpdXMgPyB0aHJlc2hvbGQgLyAyIDogcmFkaXVzO1xuXG4gICAgY29uc3QgYmVmb3JlID0gbW92ZVRvKHByZXYsIHBvaW50LCByYWRpdXNGb3JQb2ludCk7XG4gICAgY29uc3QgYWZ0ZXIgPSBtb3ZlVG8obmV4dCwgcG9pbnQsIHJhZGl1c0ZvclBvaW50KTtcblxuICAgIHJldHVybiBbXG4gICAgICBwYXRoLFxuICAgICAgYEwgJHtiZWZvcmUueH0sJHtiZWZvcmUueX1gLFxuICAgICAgYFMgJHtwb2ludC54fSwke3BvaW50Lnl9ICR7YWZ0ZXIueH0sJHthZnRlci55fWAsXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgfSwgYE0gJHtmaXJzdFBvaW50Lnh9LCR7Zmlyc3RQb2ludC55fWApO1xufVxuIiwiZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWQgPSAoKSA9PiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygxMCwgMTYpKTtcbiIsImltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL2hlbHBlcnMvbWF0aC5oZWxwZXJzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFzZXQoXG4gIGRhdGE6IG51bWJlcltdLFxuICBtaW5YOiBudW1iZXIsXG4gIG1heFg6IG51bWJlcixcbiAgbWluWTogbnVtYmVyLFxuICBtYXhZOiBudW1iZXIsXG4pIHtcbiAgLy8gRm9yIHRoZSBYIGF4aXMsIHdlIHdhbnQgdG8gbm9ybWFsaXplIGl0IGJhc2VkIG9uIGl0cyBpbmRleCBpbiB0aGUgYXJyYXkuXG4gIC8vIEZvciB0aGUgWSBheGlzLCB3ZSB3YW50IHRvIG5vcm1hbGl6ZSBpdCBiYXNlZCBvbiB0aGUgZWxlbWVudCdzIHZhbHVlLlxuICAvL1xuICAvLyBYIGF4aXMgaXMgZWFzeToganVzdCBldmVubHktc3BhY2UgZWFjaCBpdGVtIGluIHRoZSBhcnJheS5cbiAgLy8gRm9yIHRoZSBZIGF4aXMsIHdlIGZpcnN0IG5lZWQgdG8gZmluZCB0aGUgbWluIGFuZCBtYXggb2Ygb3VyIGFycmF5LFxuICAvLyBhbmQgdGhlbiBub3JtYWxpemUgdGhvc2UgdmFsdWVzIGJldHdlZW4gMCBhbmQgMS5cbiAgY29uc3QgYm91bmRhcmllc1ggPSB7IG1pbjogMCwgbWF4OiBkYXRhLmxlbmd0aCAtIDEgfTtcbiAgY29uc3QgYm91bmRhcmllc1kgPSB7IG1pbjogTWF0aC5taW4oLi4uZGF0YSksIG1heDogTWF0aC5tYXgoLi4uZGF0YSkgfTtcblxuICBjb25zdCBub3JtYWxpemVkRGF0YSA9IGRhdGEubWFwKChwb2ludCwgaW5kZXgpID0+ICh7XG4gICAgeDogbm9ybWFsaXplKGluZGV4LCBib3VuZGFyaWVzWC5taW4sIGJvdW5kYXJpZXNYLm1heCwgbWluWCwgbWF4WCksXG4gICAgeTogbm9ybWFsaXplKHBvaW50LCBib3VuZGFyaWVzWS5taW4sIGJvdW5kYXJpZXNZLm1heCwgbWluWSwgbWF4WSksXG4gIH0pKTtcblxuICAvLyBBY2NvcmRpbmcgdG8gdGhlIFNWRyBzcGVjLCBwYXRocyB3aXRoIGEgaGVpZ2h0L3dpZHRoIG9mIGAwYCBjYW4ndCBoYXZlXG4gIC8vIGxpbmVhciBncmFkaWVudHMgYXBwbGllZC4gVGhpcyBtZWFucyB0aGF0IG91ciBsaW5lcyBhcmUgaW52aXNpYmxlIHdoZW5cbiAgLy8gdGhlIGRhdGFzZXQgaXMgZmxhdCAoZWcuIFswLCAwLCAwLCAwXSkuXG4gIC8vXG4gIC8vIFRoZSBoYWNreSBzb2x1dGlvbiBpcyB0byBhcHBseSBhIHZlcnkgc2xpZ2h0IG9mZnNldCB0byB0aGUgZmlyc3QgcG9pbnQgb2ZcbiAgLy8gdGhlIGRhdGFzZXQuIEFzIHVnbHkgYXMgaXQgaXMsIGl0J3MgdGhlIGJlc3Qgc29sdXRpb24gd2UgY2FuIGZpbmQgKHRoZXJlXG4gIC8vIGFyZSB3YXlzIHdpdGhpbiB0aGUgU1ZHIHNwZWMgb2YgY2hhbmdpbmcgaXQsIGJ1dCBub3Qgd2l0aG91dCBjYXVzaW5nXG4gIC8vIGJyZWFraW5nIGNoYW5nZXMpLlxuICBpZiAoYm91bmRhcmllc1kubWluID09PSBib3VuZGFyaWVzWS5tYXgpIHtcbiAgICBub3JtYWxpemVkRGF0YVswXS55ICs9IDAuMDAwMTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkRGF0YTtcbn1cbiIsImltcG9ydCB7XG4gIGFuaW1hdGUsXG4gIGtleWZyYW1lcyxcbiAgc3RhdGUsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uLFxuICB0cmlnZ2VyLFxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgYnVpbGRMaW5lYXJQYXRoLCBidWlsZFNtb290aFBhdGggfSBmcm9tICcuLi9oZWxwZXJzL0RPTS5oZWxwZXJzJztcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4uL2hlbHBlcnMvbWF0aC5oZWxwZXJzJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi9oZWxwZXJzL21pc2MuaGVscGVycyc7XG5pbXBvcnQgeyBub3JtYWxpemVEYXRhc2V0IH0gZnJvbSAnLi90cmVuZC5oZWxwZXJzJztcblxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ3gtdHJlbmQnLFxuICB0ZW1wbGF0ZTogYFxuICA8c3ZnICpuZ0lmPVwiZGF0YSAmJiBkYXRhLmxlbmd0aCA+PSAyXCJcbiAgICBbYXR0ci53aWR0aF09XCJzdmdXaWR0aFwiXG4gICAgW2F0dHIuaGVpZ2h0XT1cInN2Z0hlaWdodFwiXG4gICAgW2F0dHIuc3Ryb2tlXT1cInN0cm9rZVwiXG4gICAgW2F0dHIuc3Ryb2tlLXdpZHRoXT1cInN0cm9rZVdpZHRoXCJcbiAgICBbYXR0ci5zdHJva2UtbGluZWNhcF09XCJzdHJva2VMaW5lY2FwXCJcbiAgICBbYXR0ci52aWV3Qm94XT1cInZpZXdCb3hcIlxuICAgIFthdHRyLnByZXNlcnZlQXNwZWN0UmF0aW9dPVwicHJlc2VydmVBc3BlY3RSYXRpb1wiXG4gID5cbiAgICA8ZGVmcyAqbmdJZj1cImdyYWRpZW50ICYmIGdyYWRpZW50Lmxlbmd0aFwiPlxuICAgICAgPGxpbmVhckdyYWRpZW50IFthdHRyLmlkXT1cImdyYWRpZW50SWRcIiB4MT1cIjAlXCIgeTE9XCIwJVwiIHgyPVwiMCVcIiB5Mj1cIjEwMCVcIj5cbiAgICAgICAgPHN0b3BcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgZyBvZiBncmFkaWVudFRyaW1tZWQ7XCJcbiAgICAgICAgICBbYXR0ci5rZXldPVwiZy5pZHhcIlxuICAgICAgICAgIFthdHRyLm9mZnNldF09XCJnLm9mZnNldFwiXG4gICAgICAgICAgW2F0dHIuc3RvcC1jb2xvcl09XCJnLnN0b3BDb2xvclwiXG4gICAgICAgIC8+XG4gICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgIDwvZGVmcz5cbiAgICA8cGF0aCBmaWxsPVwibm9uZVwiICNwYXRoRWxcbiAgICAgIFthdHRyLnN0cm9rZV09XCJwYXRoU3Ryb2tlXCIgW2F0dHIuZF09XCJkXCJcbiAgICAgIFtAcGF0aEFuaW1haXRvbl09XCJ7XG4gICAgICAgIHZhbHVlOiBhbmltYXRpb25TdGF0ZSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgYXV0b0RyYXdEdXJhdGlvbjogYXV0b0RyYXdEdXJhdGlvbixcbiAgICAgICAgICBhdXRvRHJhd0Vhc2luZzogYXV0b0RyYXdFYXNpbmcsXG4gICAgICAgICAgbGluZUxlbmd0aDogbGluZUxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdwYXRoQW5pbWFpdG9uJywgW1xuICAgICAgc3RhdGUoJ2luYWN0aXZlJywgc3R5bGUoeyBkaXNwbGF5OiAnbm9uZScgfSkpLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiBhY3RpdmUnLCBbXG4gICAgICAgIHN0eWxlKHsgZGlzcGxheTogJ2luaXRpYWwnIH0pLFxuICAgICAgICAvLyBXZSBkbyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBkYXNoIGFycmF5L29mZnNldCB0cmlja1xuICAgICAgICAvLyBodHRwczovL2Nzcy10cmlja3MuY29tL3N2Zy1saW5lLWFuaW1hdGlvbi13b3Jrcy9cbiAgICAgICAgYW5pbWF0ZSgne3sgYXV0b0RyYXdEdXJhdGlvbiB9fW1zIHt7IGF1dG9EcmF3RWFzaW5nIH19JyxcbiAgICAgICAgICBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAne3sgbGluZUxlbmd0aCB9fXB4JyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICd7eyBsaW5lTGVuZ3RoIH19cHgnLFxuICAgICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAwLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSksXG4gICAgICAgICksXG4gICAgICAgIC8vIE9uZSB1bmZvcnR1bmF0ZSBzaWRlLWVmZmVjdCBvZiB0aGUgYXV0by1kcmF3IGlzIHRoYXQgdGhlIGxpbmUgaXNcbiAgICAgICAgLy8gYWN0dWFsbHkgMSBiaWcgZGFzaCwgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBsaW5lIGl0c2VsZi4gSWYgdGhlXG4gICAgICAgIC8vIGxpbmUgbGVuZ3RoIGNoYW5nZXMgKGVnLiByYWRpdXMgY2hhbmdlLCBuZXcgZGF0YSksIHRoYXQgZGFzaCB3b24ndFxuICAgICAgICAvLyBiZSB0aGUgc2FtZSBsZW5ndGggYW55bW9yZS4gV2UgY2FuIGZpeCB0aGF0IGJ5IHJlbW92aW5nIHRob3NlXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb25jZSB0aGUgYXV0by1kcmF3IGlzIGNvbXBsZXRlZC5cbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICcnLFxuICAgICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJycsXG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIFRyZW5kQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgaWQ6IG51bWJlcjtcbiAgQElucHV0KCkgZGF0YTogKG51bWJlciB8IHt2YWx1ZTogbnVtYmVyfSlbXTtcbiAgQElucHV0KCkgc21vb3RoOiBib29sZWFuO1xuICBASW5wdXQoKSBhdXRvRHJhdyA9IGZhbHNlO1xuICBASW5wdXQoKSBhdXRvRHJhd0R1cmF0aW9uID0gMjAwMDtcbiAgQElucHV0KCkgYXV0b0RyYXdFYXNpbmcgPSAnZWFzZSc7XG4gIEBJbnB1dCgpIHdpZHRoOiBudW1iZXI7XG4gIEBJbnB1dCgpIGhlaWdodDogbnVtYmVyO1xuICBASW5wdXQoKSBwYWRkaW5nID0gODtcbiAgQElucHV0KCkgcmFkaXVzID0gMTA7XG4gIEBJbnB1dCgpIHN0cm9rZSA9ICdibGFjayc7XG4gIEBJbnB1dCgpIHN0cm9rZUxpbmVjYXAgPSAnJztcbiAgQElucHV0KCkgc3Ryb2tlV2lkdGggPSAxO1xuICBASW5wdXQoKSBncmFkaWVudDogc3RyaW5nW10gPSBbXTtcbiAgQElucHV0KCkgcHJlc2VydmVBc3BlY3RSYXRpbzogc3RyaW5nO1xuICBAVmlld0NoaWxkKCdwYXRoRWwnKSBwYXRoRWw6IEVsZW1lbnRSZWY7XG4gIGdyYWRpZW50VHJpbW1lZDogYW55W107XG4gIGQ6IGFueTtcbiAgc3ZnV2lkdGg6IHN0cmluZyB8IG51bWJlciA9ICcxMDAlJztcbiAgc3ZnSGVpZ2h0OiBzdHJpbmcgfCBudW1iZXIgPSAnMjUlJztcbiAgdmlld0JveDogc3RyaW5nO1xuICBwYXRoU3Ryb2tlOiBhbnk7XG4gIGdyYWRpZW50SWQ6IHN0cmluZztcbiAgbGluZUxlbmd0aDogbnVtYmVyO1xuICBhbmltYXRpb25TdGF0ZSA9ICcnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5ncmFkaWVudElkID0gYG5neC10cmVuZC12ZXJ0aWNhbC1ncmFkaWVudC0ke3RoaXMuaWR9YDtcbiAgfVxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICAvLyBXZSBuZWVkIGF0IGxlYXN0IDIgcG9pbnRzIHRvIGRyYXcgYSBncmFwaC5cbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGBkYXRhYCBjYW4gZWl0aGVyIGJlIGFuIGFycmF5IG9mIG51bWJlcnM6XG4gICAgLy8gWzEsIDIsIDNdXG4gICAgLy8gb3IsIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBhIHZhbHVlOlxuICAgIC8vIFt7IHZhbHVlOiAxIH0sIHsgdmFsdWU6IDIgfSwgeyB2YWx1ZTogMyB9XVxuICAgIC8vXG4gICAgLy8gRm9yIG5vdywgd2UncmUganVzdCBnb2luZyB0byBjb252ZXJ0IHRoZSBzZWNvbmQgZm9ybSB0byB0aGUgZmlyc3QuXG4gICAgLy8gTGF0ZXIgb24sIGlmL3doZW4gd2Ugc3VwcG9ydCB0b29sdGlwcywgd2UgbWF5IGFkanVzdC5cbiAgICBjb25zdCBwbGFpblZhbHVlcyA9IHRoaXMuZGF0YS5tYXAoKHBvaW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnQudmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBPdXIgdmlld2JveCBuZWVkcyB0byBiZSBpbiBhYnNvbHV0ZSB1bml0cywgc28gd2UnbGwgZGVmYXVsdCB0byAzMDB4NzVcbiAgICAvLyBPdXIgU1ZHIGNhbiBiZSBhICUsIHRob3VnaDsgdGhpcyBpcyB3aGF0IG1ha2VzIGl0IHNjYWxhYmxlLlxuICAgIC8vIEJ5IGRlZmF1bHRpbmcgdG8gcGVyY2VudGFnZXMsIHRoZSBTVkcgd2lsbCBncm93IHRvIGZpbGwgaXRzIHBhcmVudFxuICAgIC8vIGNvbnRhaW5lciwgcHJlc2VydmluZyBhIDEvNCBhc3BlY3QgcmF0aW8uXG4gICAgY29uc3Qgdmlld0JveFdpZHRoID0gdGhpcy53aWR0aCB8fCAzMDA7XG4gICAgY29uc3Qgdmlld0JveEhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IDc1O1xuICAgIHRoaXMuc3ZnV2lkdGggPSB0aGlzLndpZHRoIHx8ICcxMDAlJztcbiAgICB0aGlzLnN2Z0hlaWdodCA9IHRoaXMuaGVpZ2h0IHx8ICcyNSUnO1xuICAgIHRoaXMudmlld0JveCA9IGAwIDAgJHt2aWV3Qm94V2lkdGh9ICR7dmlld0JveEhlaWdodH1gO1xuICAgIGNvbnN0IHJvb3QgPSBsb2NhdGlvbi5ocmVmLnNwbGl0KGxvY2F0aW9uLmhhc2ggfHwgJyMnKVswXTtcbiAgICB0aGlzLnBhdGhTdHJva2UgPSAodGhpcy5ncmFkaWVudCAmJiB0aGlzLmdyYWRpZW50Lmxlbmd0aCkgPyBgdXJsKCcke3Jvb3R9IyR7dGhpcy5ncmFkaWVudElkfScpYCA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZ3JhZGllbnRUcmltbWVkID0gdGhpcy5ncmFkaWVudC5zbGljZSgpLnJldmVyc2UoKS5tYXAoKHZhbCwgaWR4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZHgsXG4gICAgICAgIHN0b3BDb2xvcjogdmFsLFxuICAgICAgICBvZmZzZXQ6IG5vcm1hbGl6ZShpZHgsIDAsIHRoaXMuZ3JhZGllbnQubGVuZ3RoIC0gMSB8fCAxKSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWVzID0gbm9ybWFsaXplRGF0YXNldChwbGFpblZhbHVlcyxcbiAgICAgIHRoaXMucGFkZGluZyxcbiAgICAgIHZpZXdCb3hXaWR0aCAtIHRoaXMucGFkZGluZyxcbiAgICAgIC8vIE5PVEU6IEJlY2F1c2UgU1ZHcyBhcmUgaW5kZXhlZCBmcm9tIHRoZSB0b3AgbGVmdCwgYnV0IG1vc3QgZGF0YSBpc1xuICAgICAgLy8gaW5kZXhlZCBmcm9tIHRoZSBib3R0b20gbGVmdCwgd2UncmUgaW52ZXJ0aW5nIHRoZSBZIG1pbi9tYXguXG4gICAgICB2aWV3Qm94SGVpZ2h0IC0gdGhpcy5wYWRkaW5nLFxuICAgICAgdGhpcy5wYWRkaW5nLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5hdXRvRHJhdyAmJiB0aGlzLmFuaW1hdGlvblN0YXRlICE9PSAnYWN0aXZlJykge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICdpbmFjdGl2ZSc7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gdGhpcy5wYXRoRWwubmF0aXZlRWxlbWVudC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmQgPSB0aGlzLnNtb290aFxuICAgICAgPyBidWlsZFNtb290aFBhdGgobm9ybWFsaXplZFZhbHVlcywgdGhpcy5yYWRpdXMpXG4gICAgICA6IGJ1aWxkTGluZWFyUGF0aChub3JtYWxpemVkVmFsdWVzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFRyZW5kQ29tcG9uZW50IH0gZnJvbSAnLi90cmVuZC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW1RyZW5kQ29tcG9uZW50XSxcbiAgZGVjbGFyYXRpb25zOiBbVHJlbmRDb21wb25lbnRdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmVuZE1vZHVsZSB7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWFBLG1CQUNFLEtBQWEsRUFDYixHQUFXLEVBQ1gsR0FBVyxFQUNYLFFBQVksRUFDWixRQUFZO0lBRFoseUJBQUEsRUFBQSxZQUFZO0lBQ1oseUJBQUEsRUFBQSxZQUFZOzs7SUFJWixJQUFJLEdBQUcsS0FBSyxHQUFHLEVBQUU7UUFDZixPQUFPLFFBQVEsQ0FBQztLQUNqQjtJQUVELE9BQU8sUUFBUSxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsS0FBSyxRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0NBQ3ZFOzs7Ozs7Ozs7OztBQW9CRCxnQkFBdUIsRUFBUyxFQUFFLElBQVcsRUFBRSxNQUFjOztJQUMzRCxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBQ2hHLElBQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUks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